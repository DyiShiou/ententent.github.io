<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>日拱一卒，功不唐捐 on LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/</link>
    <description>Recent content in 日拱一卒，功不唐捐 on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creating a New Theme</title>
      <link>https://leetcode.akaeecs.com/posts/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/posts/creating-a-new-theme/</guid>
      <description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>https://leetcode.akaeecs.com/posts/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/posts/migrate-from-jekyll/</guid>
      <description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
    <item>
      <title>1.01 Array</title>
      <link>https://leetcode.akaeecs.com/docs/topic/array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/topic/array/</guid>
      <description>Caput vino delphine in tamen vias # Cognita laeva illo fracta # Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>1.02 Linked List</title>
      <link>https://leetcode.akaeecs.com/docs/topic/linked-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/topic/linked-list/</guid>
      <description>Problem Solution Difficulty Like 0002. Add Two Numbers Java Medium 0019. Remove Nth Node From End of List Java Medium 0021. Merge Two Sorted Lists Java Easy 0023. Merge k Sorted Lists Java Hard 😎😎😎 0024. Swap Nodes in Pairs Java Medium 0025. Reverse Nodes in k-Group Java Hard 😎 0061. Rotate List Java Medium 0082. Remove Duplicates from Sorted List II Java Medium 0083. Remove Duplicates from Sorted List Java Easy 0086.</description>
    </item>
    
    <item>
      <title>3.01 Random sampling with a reservoir</title>
      <link>https://leetcode.akaeecs.com/docs/templates/reservoir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/templates/reservoir/</guid>
      <description>Caput vino delphine in tamen vias # Cognita laeva illo fracta # Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>3.02 LRU &amp; LFU</title>
      <link>https://leetcode.akaeecs.com/docs/templates/LRU/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/templates/LRU/</guid>
      <description>Caput vino delphine in tamen vias # Cognita laeva illo fracta # Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>3.03 SkipList</title>
      <link>https://leetcode.akaeecs.com/docs/templates/SkipList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/templates/SkipList/</guid>
      <description>Caput vino delphine in tamen vias # Cognita laeva illo fracta # Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>3.04 HashMap</title>
      <link>https://leetcode.akaeecs.com/docs/templates/HashMap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/templates/HashMap/</guid>
      <description>Caput vino delphine in tamen vias # Cognita laeva illo fracta # Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>3.05 Bit Operation</title>
      <link>https://leetcode.akaeecs.com/docs/templates/bit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/templates/bit/</guid>
      <description>位运算 # 位运算符 # Symbol Description Rule &amp;amp; 与 1 &amp;amp; 1 = 1, 0 ^ x = 0 ` ` 或 ~ 非 ~1 = 0, ~0 = 1 ^ 异或 0 ^ 1 = 1, 1 ^ 1 = 0, 0 ^ 0 = 0 &amp;lt;&amp;lt; 左移 各二进制位全部左移若干位，高位丢弃，低位补零 &amp;gt;&amp;gt; 算术右移 各二进制位全部右移若干位，高位补符号位 &amp;gt;&amp;gt;&amp;gt; 逻辑右移 各二进制位全部右移若干位，高位补零 Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://leetcode.akaeecs.com/posts/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/posts/goisforlovers/</guid>
      <description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>https://leetcode.akaeecs.com/posts/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/posts/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0001.-Two-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0001.-Two-Sum/</guid>
      <description>0001. Two Sum # 题目 # 给定一个整数数组 nums 和一个整数目标值 target。
在该数组中找出 和为目标值 target 的 两个 整数，并返回它们的数组下标。
假定每种输入只会对应一个答案。
数组中同一个元素在答案里不能重复出现。
思路 # 哈希 # 遍历数组，对于元素 x，若 target-x 已被访问，则找到 和为目标值 target 的两个整数。 在遍历数组时使用 HashMap 建立 数组元素 至 数组下标 的映射。 HashMap 可实现对于 元素是否被访问过 的判断。 代码 # 哈希 # class Solution { public int[] twoSum(int[] nums, int target) { int[] ans = new int[2]; Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0002.-Add-Two-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0002.-Add-Two-Numbers/</guid>
      <description>0002. Add Two Numbers # 题目 # 给定两个 非空 链表，表示两个非负整数。 每位数字均按 逆序 方式存储，每个节点只存储一位数字。 将两个数相加，并以相同形式返回一个表示和的链表。 假定除数字 0 之外，这两个数均不会以 0 开头。 解释 342 + 465 = 807
思路 # 模拟 # 代码 # 模拟 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode recursive(ListNode l1, ListNode l2, int carry) { if (l1 == null &amp;amp;&amp;amp; l2 == null) { return carry !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0013.-Roman-to-Integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0013.-Roman-to-Integer/</guid>
      <description>0013. Roman to Integer # 题目 # 罗马数字包含七种字符: I， V，X， L，C，D 和 M。
字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II，12 写做 XII，27 写做 XXVII。
罗马数字中小数字通常位于大数字的右侧，但存在以下六种特例
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换为整数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0014.-Longest-Common-Prefix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0014.-Longest-Common-Prefix/</guid>
      <description> 0014. Longest Common Prefix # 题目 # 编写一个函数来查找字符串数组中的最长公共前缀。 若不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String longestCommonPrefix(String[] strs) { String ans = &amp;#34;&amp;#34;; int candidate = 0; while (true) { for (String str: strs) { if (candidate == str.length() || str.charAt(candidate) != strs[0].charAt(candidate)) return ans; } ans += Character.toString(strs[0].charAt(candidate++)); } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0019.-Remove-Nth-Node-from-End-of-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0019.-Remove-Nth-Node-from-End-of-List/</guid>
      <description>0019. Remove Nth Node from End of List # 题目 # 删除给定链表的倒数第 n 个节点，并且返回头节点。 尝试使用一趟扫描实现。 思路 # 双指针 # 若要删除单链表的倒数第 n 个节点，需定位单链表的倒数第 n + 1 个节点。 考虑快慢指针，令快指针先走 n + 1步，之后双指针同步前进至快指针为空。 此时慢指针指向单链表的倒数第 n + 1 个节点。 设置哨兵节点有助于简化算法实现。 代码 # 双指针 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode sentinel = new ListNode(-1, head), slow = sentinel, fast = sentinel; for (int i=0; i&amp;lt;n+1; i++) fast = fast.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0020.-Valid-Parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0020.-Valid-Parentheses/</guid>
      <description>0020. Valid Parenthesis # 题目 # 给定一个只包括 &#39;(&#39;， &#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s，判断字符串是否有效。
有效字符串需满足:
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
思路 # 栈 # 可使用 栈 求解括号匹配问题 逢左括号入栈，逢右括号出栈 逢右括号 不匹配 / 遇栈空，或遍历结束时栈非空，则括号失配 代码 # 栈 # class Solution { public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;s.length(); i++) { /** 逢左括号入栈 */ char bracket = s.charAt(i); if (bracket == &amp;#39;{&amp;#39; || bracket == &amp;#39;(&amp;#39; || bracket == &amp;#39;[&amp;#39;) { stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0021.-Merge-Two-Sorted-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0021.-Merge-Two-Sorted-Lists/</guid>
      <description>0021. Merge Two Sorted Lists # 题目 # 将两个升序链表合并为一个新的升序链表并返回。 新链表是通过拼接给定的两个链表的所有节点组成的。 思路 # 递归 # 代码 # 递归 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0023.-Merge-K-Sorted-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0023.-Merge-K-Sorted-Lists/</guid>
      <description>23. Merge k Sorted Lists # 题目 # 给定一个链表数组，每个链表都已经按升序排列。
将所有链表合并到一个升序链表中，返回合并后的链表。
思路 # 构造大小为 K 的小根堆 建立堆结点和链表结点的映射 堆结点与链表结点共享变量 val 每次在堆中取最小值的结点，根据映射查找到相应链表节点，并加入到已有链表末尾。 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { private class HeapNode implements Comparable&amp;lt;HeapNode&amp;gt; { public int val; public ListNode ptr; HeapNode(int val, ListNode ptr) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0024.-Swap-Nodes-in-pairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0024.-Swap-Nodes-in-pairs/</guid>
      <description>24. Swap Nodes in Pairs # 题目 # 给定链表，两两交换其中相邻的节点，并返回交换后链表的头节点。只能进行节点交换，不能修改节点内部的值。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; else { ListNode newHead = head.next; head.next = swapPairs(newHead.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0025.-Reverse-Nodes-in-K-Group/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0025.-Reverse-Nodes-in-K-Group/</guid>
      <description>25. Reverse Nodes in K Group # 题目 # 给定链表头结点 head，每 k 个结点一组进行翻转，返回修改后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果结点总数不是 k 的整数倍，将最后的结点保持原有顺序。
不能只是单纯的改变结点内部的值，而是需要进行实际的结点交换。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public void reverseList(ListNode beforeHead, ListNode tail) { if (beforeHead == tail) return; ListNode afterTail = tail.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0026.-Remove-Duplicates-from-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0026.-Remove-Duplicates-from-Sorted-Array/</guid>
      <description>26. Remove Duplicates from Sorted Array # 题目 # 给定一个 升序排列 的数组 nums，原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致。
如果在删除重复项后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
将最终结果插入 nums 的前 k 个位置后返回 k。
在 原地 修改输入数组并在使用 O(1) 额外空间的条件下完成。
思路 # 双指针 代码 # class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 1) return 1; /** 双指针法 */ int i = 0, j = 1; while (j &amp;lt; nums.length) { if (nums[j] !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0027.-Remove-Element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0027.-Remove-Element/</guid>
      <description> 27. Remove Element # 题目 # 给定一个数组nums和一个值val，原地移除所有值等于val的元素，并返回移除后数组的新长度。
要求使用O(1)额外空间并原地修改输入数组。
思路 # 代码 # class Solution { public int removeElements(int[] nums, int val) { int sz = 0; for (int ptr = 0; ptr &amp;lt; nums.length; ptr++) if (nums[ptr] != val) nums[sz++] = nums[ptr]; return sz; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0054.-Spiral-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0054.-Spiral-Matrix/</guid>
      <description>54. Spiral Matrix # 题目 # 给定一个m行n列的矩阵matrix，按照顺时针螺旋顺序，返回矩阵中的所有元素。
思路 # 代码 # class Solution { public void circle(int[][] matrix, List&amp;lt;Integer&amp;gt; result, int top, int left, int right, int bottom) { if (top &amp;gt; bottom || left &amp;gt; right) return; if (top == bottom) { for (int j=left; j&amp;lt;=right; j++) result.add(matrix[top][j]); return; } else if (left == right) { for (int i=top; i&amp;lt;=bottom; i++) result.add(matrix[i][left]); return; } for (int j=left; j&amp;lt;right; j++) result.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0058.-Length-of-Last-Word/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0058.-Length-of-Last-Word/</guid>
      <description> 0059. Length of Last Word # 题目 # 给定字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。 单词 是仅由字母组成，不包含任何空格字符的最大子字符串。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int lengthOfLastWord(String s) { int start = -1, end = s.length() - 1; while (end &amp;gt; -1 &amp;amp;&amp;amp; s.charAt(end) == &amp;#39; &amp;#39;) end -= 1; if (end == -1) return 0; start = end; while (start &amp;gt; 0 &amp;amp;&amp;amp; s.charAt(start) != &amp;#39; &amp;#39;) start -= 1; return end - start; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0059.-Spiral-Matrix-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0059.-Spiral-Matrix-ii/</guid>
      <description> 0059. Spiral Matrix II # 题目 # 给定正整数n，生成一个包含1到n^2所有元素，且元素按顺时针顺序螺旋排列的nxn正方形矩阵matrix。
思路 # 对于n阶方阵，共有n/2个完整螺旋。
若n为奇数，则matrix[n/2][n/2]处存在独立元素n^2，不构成螺旋，应单独考虑。
对于第offset个螺旋，考虑四角元素的坐标，由左上顺时针分别为：
(offset, offset)、(offset, n-offset-1)、(n-offset-1, n-offset-1)、(n-offset-1, offset)
分别添加螺旋[上]、螺旋[右]、螺旋[下]、螺旋[左]四条边的元素，添加过程中保持区间左闭右开的一致性。
代码 # class Solution { public int[][] generateMatrix(int n) { int[][] matrix = new int [n][n]; int val = 1; for (int offset=0; offset&amp;lt;n/2; offset++) { for (int j=offset; j&amp;lt;n-offset-1; j++) matrix[offset][j] = val++; for (int i=offset; i&amp;lt;n-offset-1; i++) matrix[i][n-offset-1] = val++; for (int j=n-offset-1; j&amp;gt;offset; j--) matrix[n-offset-1][j] = val++; for (int i=n-offset-1; i&amp;gt;offset; i--) matrix[i][offset] = val++; } if (n % 2 == 1) matrix[n/2][n/2] = n*n; return matrix; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0061.-Rotate-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0061.-Rotate-List/</guid>
      <description>61. Rotate List # 题目 # 给定链表头节点head，旋转链表，将链表每个节点向右移动k个位置。
思路 # 使用指针ptr统计链表长度n。 若k % n == 0，等价于不旋转链表。 将链表尾部节点rear与头节点head相连，即ptr.next = head，链表构成环。 设给定链表长度为n，将链表每个节点向右移动k个位置，等价于将链表每个节点向右移动k%n个位置。此时第n+1-k%n个节点将作为newHead。 令ptr指向第n-k%n个节点，在此处令ptr.next = null以断开环，并返回newHead。 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null) return null; ListNode ptr = head; int length = 1; while (ptr.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0066.-Plus-One/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0066.-Plus-One/</guid>
      <description>0066. Plus One # 题目 # 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位，数组中每个数字只存储 单个 数字。
可以假定除整数 0 之外，这个整数不会以零开头。
思路 # 代码 # class Solution { public int[] plusOne(int[] digits) { int carry = 1; for (int i = digits.length - 1; i &amp;gt;= 0; i--) { int newDigit = (digits[i] + carry) % 0; carry = (digits[i] + carry) / 10; digits[i] = newDigit; } if (carry == 0) return digits; int[] ans = new int[digits.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0067.-Add-Binary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0067.-Add-Binary/</guid>
      <description>0067. Add Binary # 题目 # 给定两个二进制字符串a和b，以二进制字符串的形式返回它们的和。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String addBinary(String a, String b) { String longer = a.length() &amp;gt; b.length() ? a : b; int ptrLonger = longer.length() - 1; String shorter = a.length() &amp;gt; b.length() ? b : a; int ptrShorter = shorter.length() - 1; char[] ans = longer.toCharArray(); int sum = 0, carry = 0; while (ptrShorter &amp;gt;= 0) { sum = longer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0070.-Climbing-Stairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0070.-Climbing-Stairs/</guid>
      <description> 70. Climbing Stairs # 题目 # 假定某人正在爬楼梯，需要 n 阶才能到达楼顶。
每次可以爬 1 或 2 个台阶。求出爬到楼顶的方案总数。
思路 # 代码 # class Solution { public int climbStairs(int n) { if (n == 1 || n == 2) return n; int prev = 1, cur = 2; for (int i = 3; i &amp;lt;= n; i++) { int temp = prev + cur; prev = cur; cur = temp; } return cur; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0082.-Remove-Duplicates-from-Sorted-List-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0082.-Remove-Duplicates-from-Sorted-List-ii/</guid>
      <description>82. Remove Duplicates from Sorted List II # 题目 # 给定排序链表的头节点head，删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表。
链表数据保证链表已经按升序排列。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode sentinel = new ListNode(-1, null); ListNode preserve = sentinel, anchor = head; while (anchor !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0083.-Remove-Duplicates-from-Sorted-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0083.-Remove-Duplicates-from-Sorted-List/</guid>
      <description>83. Remove Duplicates from Sorted List # 题目 # 给定排序链表的头节点head，删除所有重复元素，使每个元素只出现一次。返回已排序的链表。
链表数据保证链表已经按升序排列。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode ptr = head; while (ptr != null &amp;amp;&amp;amp; ptr.next != null) { if (ptr.next.val == ptr.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0086.-Partition-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0086.-Partition-List/</guid>
      <description>86. Partition List # 题目 # 给定链表头节点head和一个特定值x，对链表进行分隔，使得所有小于x的节点都出现在大于或等于x的节点之前。应保留两个分区中每个节点的初始相对位置。
思路 # 定位第一个值小于x的节点的前驱节点secLessLast，以及第一个值不小于x的节点secMoreFirst 设置preserve指针，指向当前secMore分区的最后一个节点 移动preserve指针，每次查看preserve指针的下一个节点，若其值小于x，则将此节点设置为新的secLessLast节点 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode partition(ListNode head, int x) { ListNode sentinel = new ListNode(-1, head); ListNode secLessLast = sentinel; while (secLessLast.next != null &amp;amp;&amp;amp; secLessLast.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0088.-Merge-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0088.-Merge-Sorted-Array/</guid>
      <description>0088. Merge Sorted Array # 题目 # 给定两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 合并后的元素存储在数组 nums1 中。设置 nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 思路 # 双指针 # 数组 nums1 和 nums2 是有序数组。 从前向后遍历时需要移动数组元素，从后向前遍历会简化过程。 代码 # 双指针 # class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int ptr1 = m - 1, ptr2 = n - 1, ptr = m + n - 1; while (ptr1 &amp;gt; -1 &amp;amp;&amp;amp; ptr2 &amp;gt; -1) nums1[ptr--] = nums1[ptr1] &amp;gt;= nums2[ptr2] ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0092.-Reverse-Linked-List-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0092.-Reverse-Linked-List-ii/</guid>
      <description>92. Reverse Linked List ii # 题目 # 给定单链表头节点head和两个整数left和right，其中left &amp;lt;= right。反转从位置left到位置right的链表节点，返回反转后的链表。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public void reverseList(ListNode head, ListNode tail) { if (head == tail) return; reverseList(head.next, tail); head.next.next = head; } public ListNode reverseBetween(ListNode head, int left, int right) { ListNode sentinel = new ListNode(-1, head); ListNode beforeLeft = sentinel, ptrRight = sentinel; for (int i=0; i&amp;lt;left-1; i++) beforeLeft = beforeLeft.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0094.-Binary-Tree-Inorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0094.-Binary-Tree-Inorder-Traversal/</guid>
      <description>94. Binary Tree Inorder Traversal # 题目 # 给定二叉树的根节点 root，返回它节点值的 中序 遍历。
思路 # 代码 # 暴力解 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public void traversal(TreeNode root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; traverse(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0098.-Validate-Binary-Search-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0001-to-0099/0098.-Validate-Binary-Search-Tree/</guid>
      <description>0098. Validate Binary Search Tree # 题目 # 给定二叉树根节点 root，判断其是否是一个有效的 BST 有效 BST 定义如下 节点的左子树只包含 小于 当前节点的数 节点的右子树只包含 大于 当前节点的数 所有左子树和右子树自身也须是 BST 思路 # 中序遍历 # 代码 # 中序遍历+列表 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public void reverse(TreeNode root, List&amp;lt;Integer&amp;gt; values) { if (root == null) return; traverse(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0100.-Same-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0100.-Same-Tree/</guid>
      <description>100. Same Tree # 题目 # 给定两棵二叉树的根节点 p 和 q，判断这两棵树是否相同。
若两棵树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null) return q == null; if (q == null) return false; return (p.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0101.-Symmetric-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0101.-Symmetric-Tree/</guid>
      <description>101. Symmetric Tree # 题目 # 给定二叉树的根节点 root，检查它是否轴对称。
思路 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean checkTwoNodes(TreeNode node1, TreeNode2) { if (node1 == null &amp;amp;&amp;amp; node2 == null) return true; if (node1 == null &amp;amp;&amp;amp; node2 !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0102.-Binary-Tree-Level-Order-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0102.-Binary-Tree-Level-Order-Traversal/</guid>
      <description>102. Binary Tree Level Order Traversal # 题目 # 给定二叉树的根节点 root，返回其节点值的 层序遍历。
即逐层地，从左到右访问所有节点。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0103.-Binary-Tree-Zigzag-Level-Order-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0103.-Binary-Tree-Zigzag-Level-Order-Traversal/</guid>
      <description>103. Binary Tree Zigzag Level Order Traversal # 题目 # 给定二叉树的根节点 root，返回其节点值的 锯齿形层序遍历。
即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。
思路 # 双栈 代码 # 双栈 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Stack&amp;lt;TreeNode&amp;gt; leftStack = new Stack&amp;lt;&amp;gt;(); Stack&amp;lt;TreeNode&amp;gt; rightStack = new Stack&amp;lt;&amp;gt;(); leftStack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0104.-Maximum-Depth-of-BInary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0104.-Maximum-Depth-of-BInary-Tree/</guid>
      <description>104. Maximum Depth of Binary Tree # 题目 # 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
思路 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; return 1 + Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0107.-Binary-Tree-Level-Order-Traversal-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0107.-Binary-Tree-Level-Order-Traversal-II/</guid>
      <description>107. Binary Tree Level Order Traversal II # 题目 # 给定二叉树的根节点 root，返回其节点值 自底向上的层序遍历。
从叶子节点所在层到根节点所在的层，逐层从左向右遍历。
思路 # 队列的栈: 先建栈，后出栈 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Stack&amp;lt;Queue&amp;lt;TreeNode&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0110.-Balanced-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0110.-Balanced-Binary-Tree/</guid>
      <description>110. Balanced Binary Tree # 题目 # 给定一棵二叉树，判断其是否为高度平衡的二叉树。
高度平衡二叉树定义为：每个节点的左右两个子树的高度差的绝对值不超过1。
思路 # 编写代码的过程中会发现，需要类型分别为 boolean 和 int 的两个返回值，对应 以 root 为根节点的树是否高度平衡 和 以 root 为根节点的树的高度 鉴于树高为非负整数，故负整数可用于表示 以 root 为根节点的树非高度平衡 树的高度通过子树的高度计算得出。且负树高具有传递性。 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { /** 以 -1 表示 root 非高度平衡二叉树 */ public int depth(TreeNode root) { if (root == null) return 0; int leftDepth = depth(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0111.-Minimum-Depth-of-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0111.-Minimum-Depth-of-Binary-Tree/</guid>
      <description>111. Minimum Depth of Binary Tree # 题目 # 给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
思路 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0112.-Path-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0112.-Path-Sum/</guid>
      <description>112. Path Sum # 题目 # 给定二叉树的根节点 root 和一个表示目标和的整数 targetSum。判断该树上是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum。
叶子节点 是指没有子节点的节点。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0116.-Populating-Next-Right-Pointers-in-Each-Node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0116.-Populating-Next-Right-Pointers-in-Each-Node/</guid>
      <description>0116. Populating Next Right Pointers in Each Node # 题目 # 给定一个 完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
思路 # 层序遍历 代码 # 层序遍历 # class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } } class Solution { public Node connect(Node root) { if (root == null) return null; Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0117.-Populating-Next-Right-Pointers-in-Each-Node-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0117.-Populating-Next-Right-Pointers-in-Each-Node-ii/</guid>
      <description>0117. Populating Next Right Pointers in Each Node II # 题目 # 给定一个二叉树
struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
思路 # 层序遍历 代码 # 层序遍历 # class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } } class Solution { public Node connect(Node root) { if (root == null) return null; Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0118.-Pascals-Triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0118.-Pascals-Triangle/</guid>
      <description>0118. Pascal&amp;rsquo;s Triangle # 题目 # 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 「杨辉三角」中，每个数是它左上方和右上方的数之和。 思路 # 模拟 # 代码 # 模拟 # class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); ans.add(new LinkedList&amp;lt;&amp;gt;()); ans.get(0).add(1); if (numRows == 1) return ans; for (int i = 1; i &amp;lt; numRows; i++) { ans.add(new LinkedList&amp;lt;&amp;gt;()); ans.get(i).add(1); for (int j = 0; j &amp;lt; ans.get(i - 1).size() - 1; j++) { ans.get(i).add(ans.get(i - 1).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0121.-Best-Time-to-Buy-ans-Sell-Stock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0121.-Best-Time-to-Buy-ans-Sell-Stock/</guid>
      <description> 0121. Best Time to Buy and Sell Stock # 题目 # 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
思路 # 贪心 # 代码 # 贪心 # class Solution { public int maxProfit(int[] prices) { int ans = 0, minPrice = prices[0]; for (int price: prices) { minPrice = Math.min(minPrice, price); ans = Math.max(ans, price - minPrice); } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0125.-Valid-Palindrome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0125.-Valid-Palindrome/</guid>
      <description>0125. Valid Palindrome # 题目 # 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样，则可以认为该短语是一个 回文串。
字母和数字都属于字母数字字符。
给定字符串 s，判断其是否为 回文串。
思路 # 代码 # class Solution { public boolean isPalindrome(String s) { int left = 0, right = s.length() - 1; while (left &amp;lt; right) { while (left &amp;lt; s.length() &amp;amp;&amp;amp; Character.isLetterOrDigit(s.charAt(left)) == false) left += 1; while (right &amp;gt;= 0 &amp;amp;&amp;amp; Character.isLetterOfDigit(s.charAt(right)) == false) right -= 1; if (left &amp;gt;= right) return true; if (Character.toLowerCase(s.charAt(left++)) != Character.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0136.-Single-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0136.-Single-Number/</guid>
      <description> 0136. Single Number # 题目 # 给定一个 非空 整数数组 nums，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。
设计并实现线性时间复杂度的算法来解决此问题，且算法只使用常量额外空间。
思路 # x ^ x = 0、 x ^ 0 = x
代码 # class Solution { public int singleNumber(int[] nums) { int result = 0; for (int num: nums) result = result ^ num; return result; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0137.-Single-Number-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0137.-Single-Number-ii/</guid>
      <description>137. Single Number ii # 题目 # 给定整数数组 nums，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次。找出并返回只出现了一次的元素。
设计并实现线性时间复杂度的算法来解决此问题，且算法只使用常量额外空间。
思路 # 位数统计 代码 # class Solution { public int singleNumber(int[] nums) { int[] count = new int[32]; for (int num: nums) { for (int i = 0; i &amp;lt; 32; i++) { if (((num &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) count[i] += 1; } } int ans = 0; for (int i = 0; i &amp;lt; 32; i++) { if (count[i] % 3 == 1) ans ^= (1 &amp;lt;&amp;lt; i); } return ans; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0138.-Copy-List-with-Random-Pointer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0138.-Copy-List-with-Random-Pointer/</guid>
      <description>0138. Copy List with Random Pointer # 题目 # 给定长度为 n 的链表，每个节点包含一个额外增加的随机指针 random，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。
思路 # 通过两次遍历实现深拷贝。
第一趟遍历，为新链表逐个生成节点，并构建新旧链表节点之间的对应关系。 第二趟遍历，为新链表深复制随机指针。 代码 # class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } class Solution { public Node copyRandomList(Node head) { Node sentinelOld = new Node(-1); sentinelOld.next = head; Node sentinelNew = new Node(-1); Node ptrOld = sentinelOld, ptrNew = sentinelNew; HashMap&amp;lt;Node, Node&amp;gt; correspond = new HashMap&amp;lt;Node, Node&amp;gt;(); while (ptrOld.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0141.-Linked-List-Cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0141.-Linked-List-Cycle/</guid>
      <description>141. Linked List Cycle # 题目 # 给定链表头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
思路 # 代码 # class ListNode { int val; ListNode next; ListNode (int x) { val = x; next = null; } } public class Solution { public boolean hasCycle(ListNode head) { ListNode slow=head, fast=head; while (fast != null &amp;amp;&amp;amp; fast.next != null) { fast = fast.next.next; slow = slow.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0142.-Linked-List-Cycle-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0142.-Linked-List-Cycle-ii/</guid>
      <description>142. Linked List Cycle II # 题目 # 给定链表头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
不允许修改 链表。
思路 # 设head至环入口距离为x，环入口至相遇处距离为y，相遇处至环入口距离为z assert: 相遇时slow指针在环内尚未走过完整的一圈。 proof: 若slow指针在环入口处与fast指针相遇，则此时slow指针尚未走过完整的一圈。若slow指针在环入口处尚未与fast指针相遇，则此时slow指针与fast指针的相对距离小于一圈，又因为fast指针追击slow指针的相对速度为1，则在slow指针尚未走过一圈的时间内，fast指针就将追击slow指针。故相遇时slow指针在环内尚未走过完整的一圈。 相遇时slow指针走过的距离可表示为x+y，fast指针走过的距离可表示为x+n(y+z)+y 有等式2(x+y) = x+y+n(y+z)，化简有x=(n-1)(y+z) + z 新建指针ptr指向head。令fast指针与ptr指针同时以速度1向前移动，则fast指针与ptr指针将在环入口处相遇。 代码 # class ListNode { int val; ListNode next; ListNode (int x) { val = x; next = null; } } public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null &amp;amp;&amp;amp; fast.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0143.-Reorder-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0143.-Reorder-List/</guid>
      <description>143. Reorder List # 题目 # 给定一个单链表 L 的头节点 head ，单链表 L 表示为：
L0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为：
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
思路 # 寻找链表中心结点 + 翻转链表 + 合并链表
代码 # 暴力解 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0144.-Binary-Tree-Preorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0144.-Binary-Tree-Preorder-Traversal/</guid>
      <description>144. Binary Tree Preorder Traversal # 题目 # 给定二叉树的根节点 root，返回它节点值的 前序 遍历。
思路 # 代码 # 暴力解 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public void traversal(TreeNode root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0145.-Binary-Tree-Postorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0145.-Binary-Tree-Postorder-Traversal/</guid>
      <description>145. Binary Tree Postorder Traversal # 题目 # 给定二叉树的根节点 root，返回它节点值的 后序 遍历。
思路 # 代码 # 暴力解 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public void traversal(TreeNode root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; traverse(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0146.-LRU-Cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0146.-LRU-Cache/</guid>
      <description>146. LRU Cache # 题目 # 设计并实现一个满足 LRU（最近最少使用）缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value；如果不存在，则向缓存中插入该组 key-value，如果插入操作导致关键字数量超过 capacity，则应该逐出最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 思路 # 使用 双向链表 结合 哈希表 实现 LRU Cache 数据结构。
代码 # class LRUCache { private class ListNode { int key; int val; public ListNode prev; public ListNode next; ListNode (int key, int val, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0147.-Insertion-Sort-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0147.-Insertion-Sort-List/</guid>
      <description>147. Insertion Sort List # 题目 # 给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。
插入排序 算法的步骤:
插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 思路 # 代码 # class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode insertSortList(ListNode head) { ListNode sentinel = new ListNode(-1, head); /** 设置 preserve 指向已排序链表的尾结点，每次新处理的结点为 preserve.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0148.-Sort-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0148.-Sort-List/</guid>
      <description>148. Sort List # 题目 # 给定链表头结点 head，将其按 升序 排列并返回 排序后的链表
思路 # 分治，归并排序：寻找链表中心结点，分别对链表前半段和后半段排序，合并排序后的前半段链表和后半段链表 代码 # public class ListNode int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode mergeTwoLists(ListNode headA, ListNode headB) { if (headA == null) return headB; if (headB == null) return headA; ListNode sentinel = new ListNode(-1, null); ListNode ptr = sentinel; while (headA !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0150.-Evaluate-Reverse-Polish-Notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0150.-Evaluate-Reverse-Polish-Notation/</guid>
      <description>0150. Evaluate Reverse Polish Notation # 题目 # 给定字符串数组 tokens，表示一个根据 逆波兰表示法 表示的算术表达式。
返回表达式的值。
注意：
有效的算符为 &#39;+&#39;、&#39;-&#39;、&#39;*&#39; 和 &#39;/&#39; 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 思路 # 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 代码 # class Solution { public int evalRPN(String[] tokens) { Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for(String token: tokens) { switch (token) { case &amp;#34;+&amp;#34; : stack.push(stack.pop() + stack.pop()); break; case &amp;#34;-&amp;#34; : int operand_2 = stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0160.-Intersection-of-Two-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0160.-Intersection-of-Two-Linked-List/</guid>
      <description>160. Intersection of Two Linked Lists # 题目 # 给定两个单链表的头节点headA和headB，找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode ptrA = headA, ptrB = headB; while (ptrA != ptrB) { ptrA = ptrA.next; ptrB = ptrB.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0167.-Two-Sum-II-Input-Array-Is-Sorted/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0167.-Two-Sum-II-Input-Array-Is-Sorted/</guid>
      <description>0167. Two Sum II - Input Array Is Sorted # 题目 # 给定一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 从数组中找出满足相加之和等于目标数 target 的两个数的下标。 如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length 。 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。 假设每个输入 只对应唯一的答案 ，且 不可以 重复使用相同的元素。 所设计的解决方案必须只使用常量级的额外空间。 思路 # 双指针 # 代码 # 双指针 # class Solution { public int[] twoSum(int[] numbers, int target) { int[] ans = new int[2]; int left = 0, right = numbers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0168.-Excel-Sheet-Column-Title/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0168.-Excel-Sheet-Column-Title/</guid>
      <description>0168. Excel Sheet Column Title # 题目 # 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。
例如
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... 思路 # 模拟 # 代码 # 模拟 # class Solution { public String convertToTitle(int columnNumber) { String ans = &amp;#34;&amp;#34;; while (--columnNumber &amp;gt;= 0) { ans = String.valueOf((char)(&amp;#39;A&amp;#39; + columnNumber % 26)) + ans; columnNumber /= 26; } return ans; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0169.-Majority-Element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0169.-Majority-Element/</guid>
      <description>169. Majority Element # 题目 # 给定一个大小为 n 的数组 nums，返回其中的多数元素。多数元素是指在数组中出现次数 大于 n/2 的元素。
假定数组非空，且给定的数组总是存在多数元素。
思路 # 摩尔投票法 代码 # class Solution { public int majorityElement(int[] nums) { int major = -1, count = 0; for (int num: nums) { if (count == 0) { major = num; count = 1; } else if (major == num) { count += 1; } else count -= 1; } return major; } } 致谢 # 田野吹吹风</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0171.-Excel-Sheet-Column-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0171.-Excel-Sheet-Column-Number/</guid>
      <description>0171. Excel Sheet Column Number # 题目 # 给你一个整数 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。
例如
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... 思路 # 模拟 # 代码 # 模拟 # class Solution { public int titleToNumber(String columnTitle) { int ans = 0; char[] arr = columnTitle.toCharArray(); for (int i = 0; i &amp;lt; arr.length; i++) { ans += Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0189.-Rotate-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0189.-Rotate-Array/</guid>
      <description>0189. Rotate Array # 题目 # 给定数组 nums，将数组中的元素向右轮转 k 个位置，k 为非负整数。 思路 # 翻转数组 # # visualization (k = 3) nums = &amp;#34;----&amp;gt;--&amp;gt;&amp;#34; result = &amp;#34;--&amp;gt;----&amp;gt;&amp;#34; reverse &amp;#34;----&amp;gt;--&amp;gt;&amp;#34; to &amp;#34;&amp;lt;--&amp;lt;----&amp;#34; reverse &amp;#34;&amp;lt;--&amp;#34; to &amp;#34;--&amp;gt;&amp;#34; reverse &amp;#34;&amp;lt;----&amp;#34; to &amp;#34;----&amp;gt;&amp;#34; finally get &amp;#34;--&amp;gt;----&amp;gt;&amp;#34; 代码 # 翻转数组 # public class Solution { public int hamingWeight(int n) { int numOnes = 0; for (int i = 31; i &amp;gt;= 0; i--) { if ( ((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 1 ) numOnes += 1; } return numOnes;s } } 致谢 # 力扣官方题解</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0191.-Number-of-1-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0191.-Number-of-1-Bits/</guid>
      <description> 0191. Number of 1 Bits # 题目 # 编写一个函数，输入是一个无符号整数 (以二进制串的形式)，返回其二进制表达式中数字位数位 &#39;1&#39; 的个数，也称为 汉明重量。
在 Java 中，整数的表示有以下两个特点：
没有无符号整数类型，输入和输出都将被指定为有符号整数类型。 编译器使用 二进制补码 表示有符号整数。 思路 # 代码 # public class Solution { public int hamingWeight(int n) { int numOnes = 0; for (int i = 31; i &amp;gt;= 0; i--) { if ( ((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 1 ) numOnes += 1; } return numOnes;s } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0198.-House-Robber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0198.-House-Robber/</guid>
      <description>0198. House Robber # 题目 # 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 思路 # 动态规划 # 代码 # 动态规划 # class Solution { public int rob(int[] nums) { int[] profits = new int[nums.length]; int ans = 1; for (int i = 0; i &amp;lt; nums.length; i++) { if (i == 0) profits[i] = nums[0]; else if (i == 1) profits[i] = Math.max(nums[0], nums[1]); else profits[i] = Math.max(profits[i-2] + nums[i], profits[i - 1]); ans = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0199.-Binary-Tree-Right-Side-View/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0199.-Binary-Tree-Right-Side-View/</guid>
      <description>199. Binary Tree Right Side View # 题目 # 给定一个二叉树的 根节点 root，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;Integer&amp;gt; rightSideView(TreeNode root) { List&amp;lt;Integer&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0202.-Happy-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0202.-Happy-Number/</guid>
      <description> 202. Happe Number # 题目 # 判断一个数 n 是否为快乐数。是快乐数则返回 true，否则返回 false。
「快乐数」 定义为:
对于一个正整数，每一次将该数替换为它每个位置上数字的平方和。 重复这个过程直至这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为1，那么这个数就是快乐数。 思路 # 题目中声明，该过程有两种情况：「该数最终变为1」，「该数进入无限循环，变不到1」。
如果这句话有所关注，就比较容易地想到用哈希集合解决该问题。
否则将需要思考快乐数的演化情况，演化情况可参考 力扣官方题解。
代码 # class Solution { public boolean isHappy(int n) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); while (n != 1) { if (set.contains(n) == true) return false; set.add(n); int new Number = 0; while (n != 0) { newNumber += Math.pow(n%10, 2); n /= 10; } n = newNumber; } return true; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0203.-Remove-Linked-List-Elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0203.-Remove-Linked-List-Elements/</guid>
      <description> 203. Remove Linked List Elements # 题目 # 给定链表头节点head和一个整数val，删除链表中所有满足Node.val == val的节点，并返回新的头节点。
思路 # 代码 # class Solution { public void moveZeros(int[] nums) { int slow = 0, fast = 0; while (fast &amp;lt; nums.length) { if (nums[fast] != 0) nums[slow++] = nums[fast]; fast += 1; } while (slow &amp;lt; nums.length) nums[slow++] = 0; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0205.-Isomorphic-Strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0205.-Isomorphic-Strings/</guid>
      <description>0205. Isomorphic Strings # 题目 # 给定两个字符串 s 和 t ，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 要求每个出现的字符都映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。 思路 # 哈希 # 代码 # 哈希 # class Solution { public boolean isIsomorphic(String s, String t) { if (s.length() != t.length()) return false; Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; s.length(); i++) { if (map.containsKey(s.charAt(i)) &amp;amp;&amp;amp; map.get(s.charAt(i)) != t.charAt(i)) return false; if (map.containsKey(s.charAt(i)) == false &amp;amp;&amp;amp; map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0206.-Reverse-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0206.-Reverse-Linked-List/</guid>
      <description>206. Reverse Linked List # 题目 # 给定单链表头节点head，反转并返回反转后的链表。
思路 # 代码 # 递归 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode newHead = reverseList(head.next); head.next.next = head; head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0209.-Minimum-Size-Subarray-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0209.-Minimum-Size-Subarray-Sum/</guid>
      <description> 209. Minimum Size Subarray Sum # 题目 # 给定一个含有n个正整数的数组和一个正整数target。找出该数组中满足其和&amp;gt;=target的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回0。
思路 # 代码 # class Solution { public int minSubArrayLen(int target, int[] nums) { if (nums == null) return 0; int left=0, right=0, len=0, cumSum=0; while (left &amp;lt;= right &amp;amp;&amp;amp; right &amp;lt; nums.length) { curSum += nums[right]; if (curSum &amp;gt;= target) { if (len == 0 || len &amp;gt; right-left+1) len = right-left+1; curSum -= nums[left]; left += 1; curSum -= nums[right]; } else right += 1; } return len; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0217.-Contains-Duplicate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0217.-Contains-Duplicate/</guid>
      <description> 0217. Contains Duplicate # 题目 # 给定整数数组 nums 。 若存在出现 至少两次 的元素，返回 true ；否则返回 false 。 思路 # 哈希 # 代码 # 哈希 # class Solution { public boolean containsDuplicate(int[] nums) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int num: nums) if (set.contains(num) == true) return true; else set.add(num); return false; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0219.-Contains-Duplicate-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0219.-Contains-Duplicate-ii/</guid>
      <description>0219. Contains Duplicate ii # 题目 # 给你一个整数数组 nums 和一个整数 k 判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &amp;lt;= k 。 如果存在，返回 true ；否则，返回 false 。 思路 # 滑窗+哈希 # 代码 # 滑窗+哈希 # class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { if (i &amp;gt; k) set.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0226.-Invert-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0226.-Invert-Binary-Tree/</guid>
      <description>226. Invert Binary Tree # 题目 # 给定二叉树的根节点 root，翻转这棵二叉树，并返回其根节点。
思路 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public TreeNode invertTree(TreeNode root) { if (root == null || (root.left == null &amp;amp;&amp;amp; root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0231.-Power-of-Two/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0231.-Power-of-Two/</guid>
      <description>231. Power of Two # 题目 # 给定一个整数 n，判断该整数是否是 2的幂次方。如果是，返回 true；否则，返回 false。
如果存在一个整数 x 使得 n == 2^x，则认为 n 是 2 的幂次方。
思路 # 对于数字 2^x，当且仅当加数不小于 2^x 时，和才不小于 2^(x+1) 若 n 的二进制表示中存在不止一个 1，则该整数不是 2 的幂次方。 代码 # 较繁琐的实现 # class Solution { public boolean isPowerOfTwo(int n) { if (n &amp;lt;= 0) return false; boolean flag = false; for (int i = 31; i &amp;gt;= 0; i--) { if (((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) { if (flag == false) flag = true; else return false; } } return true; } } 利用位运算简化代码 # class Solution { public boolean isPowerOfTwo(int n) { return n &amp;gt; 0 &amp;amp;&amp;amp; (n &amp;amp; n-1) == 0;s } } 致谢 # Krahets</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0232.-Implement-Queue-using-Stacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0232.-Implement-Queue-using-Stacks/</guid>
      <description>0255. Implement Queue using Stacks # 题目 # 使用两个栈实现一个先入先出的栈，支持普通队列的全部四种操作。 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true；否则，返回 false 思路 # 使用两个栈实现队列 # 代码 # 使用两个栈实现队列 # class MyQueue { Stack&amp;lt;Integer&amp;gt; inStack, outStack; public MyQueue() { this.inStack = new Stack&amp;lt;&amp;gt;(); this.outStack = new Stack&amp;lt;&amp;gt;(); } public void push(int x) { this.inStack.push(x); } public int pop() { if (this.outStack.size() == 0) { while (this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0234.-Palindrome-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0234.-Palindrome-Linked-List/</guid>
      <description>234. Palindrome Linked List # 题目 # 给定单链表的头节点head，判断该链表是否为回文链表。
考虑使用O(n)时间复杂度和O(1)空间复杂度解决此题。
思路 # 分割、翻转 # 使用快慢指针找到链表中心节点。 如果链表长度为偶，则fast.next == null时，slow指向链表前半部分的最后一个节点。 如果链表长度为奇，则fast == null时，slow指向链表的轴节点。 使用迭代的方式以O(1)空间复杂度翻转链表的后半部分。 判断链表是否为回文链表。 将后半部分链表恢复原状，避免对链表的破坏。 返回结果。 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode locateMiddle(ListNode head) { ListNode slow = head, fast = head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0237.-Delete-Nodes-in-A-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0237.-Delete-Nodes-in-A-Linked-List/</guid>
      <description> 237. Delete Node in A Linked List # 题目 # 有一个单链表的head，想要删除它的一个节点node。
给定需要删除的节点node，并且无法访问第一个节点head。
链表所有值都是唯一的，且给定的节点node不是链表中的最后一个节点。
删除节点的意思是指：
给定节点的值不应该存在于链表中。 链表中的节点数应该减少1。 node前面所有值的顺序相同。 node后面所有值的顺序相同。 思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0242.-Valid-Anagram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0242.-Valid-Anagram/</guid>
      <description>237. Valid Anagram # 题目 # 给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。
若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
思路 # 代码 # public Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) return false; Map&amp;lt;Character, Integer&amp;gt; sMap = new HashMap&amp;lt;&amp;gt;(); Map&amp;lt;Character, Integer&amp;gt; tMap = new HashMap&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;s.length(); i++) { char ch = s.charAt(i); int times = sMap.containsKey(ch) == false ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0255.-Implement-Stack-using-Queues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0255.-Implement-Stack-using-Queues/</guid>
      <description>0255. Implement Stack using Queues # 题目 # 使用两个队列实现一个后入先出的栈，支持普通栈的全部四种操作。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 思路 # 使用两个队列实现栈 # 代码 # 使用两个队列实现栈 # class MyStack { private Queue&amp;lt;Integer&amp;gt; stack, queue; public MyStack() { this.stack = new LinkedList&amp;lt;&amp;gt;(); this.queue = new LinkedList&amp;lt;&amp;gt;(); } public void push(int x) { if (this.stack.size() == 0) this.stack.offer(x); else { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0258.-Add-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0258.-Add-Digits/</guid>
      <description>0258. Add Digits # 题目 # 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。 思路 # 模拟 # 数字根 # 代码 # 模拟 # class Solution { public int foo(int num) { int ans = 0; while (num &amp;gt; 0) { ans += num % 10; num /= 10; } return ans; } public int addDigits(int num) { while (num &amp;gt; 9) { num = foo(num); } return num; } } 致谢 # windliang</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0263.-Ugly-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0263.-Ugly-Number/</guid>
      <description> 263. Ugly Number # 题目 # 丑数 是只包含质因数 2、3 和 5 的正整数。
给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。
-2^31 &amp;lt;= n &amp;lt;= 2^31 - 1
思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean isUgly(int n) { if (n &amp;lt;= 0) return false; while (n % 2 == 0) n /= 2; while (n % 3 == 0) n /= 3; while (n % 5 == 0) n /= 5; return n == 1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0268.-Missing-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0268.-Missing-Number/</guid>
      <description>268. Missing Number # 题目 # 给定一个包含 [0, n] 中 n 个数的数组 nums，找出 [0, n] 这个范围内没有出现在数组中的那个数。
思路 # 数学: expectSum - actualSum 异或: x ^ x = 0，expect ^ actual 原地哈希: :question: 代码 # 数学 # class Solution { public int missingNumber(int[] nums) { int n = nums.length; int expected = n * (n + 1) / 2; int actual = 0; for (int num: nums) actual += num; return exptected - actual; } } 异或 # class Solution { public int missingNumber(int[] nums) { int whole = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0278.-First-Bad-Version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0278.-First-Bad-Version/</guid>
      <description> 0035. Search Insert Position # 题目 # 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 使用时间复杂度为 O(log n) 的算法。 思路 # 二分查找（左闭右开） # 令右指针指向已知大于目标值的最靠前位置，左指针指向已知不大于目标值的最靠后位置 当两指针相遇，所指向位置为元素的插入位置 代码 # 二分查找（左闭右开） # class Solution { public int searchInsert(int[] nums, int target) { int left = 0, right = nums.length; while (left &amp;lt; right) { int medium = left + (right - left) / 2; if (nums[medium] == target) return medium; else if (nums[medium] &amp;gt; target) right = medium; else left = medium + 1; } return right; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0283.-Move-Zeros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0283.-Move-Zeros/</guid>
      <description> 0283. Move Zeros # 题目 # 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末位，同时保持非零元素的相对顺序。
必须在不复制数组的情况下原地对数组进行操作。
思路 # 代码 # class Solution { public void moveZeros(int[] nums) { int slow = 0, fast = 0; while (fast &amp;lt; nums.length) { if (nums[fast] != 0) nums[slow++] = nums[fast]; fast++; } while (slow &amp;lt; nums.length) nums[slow++] = 0; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0290.-Word-Pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0290.-Word-Pattern/</guid>
      <description>0290. Word Pattern # 题目 # 给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。 思路 # 哈希 # 代码 # 哈希 # class Solution { public boolean wordPattern(String pattern, String s) { String[] words = s.split(&amp;#34; &amp;#34;); if (pattern.length() != words.length) return false; Map&amp;lt;Character, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; pattern.length(); i++) { char pat = pattern.charAt(i); String word = words[i]; if (map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0292.-Nim-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0200-to-0299/0292.-Nim-Game/</guid>
      <description> 0292. Nim Game # 题目 # 两人玩 Nim 游戏
桌子上有一堆石头。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设两人所走每一步都是最优解。
编写函数，判断先手能否在给定石头数量为 n 的情况下赢得游戏。
思路 # 博弈 # 若 n 不是 4 的幂，则在每回合先手总可以令后手面对总数为 4的若干次幂 的石头，直至令后手面对 4块石头。此时先手必胜。 同理，若 n 是 4 的幂，则先手必败。 代码 # 博弈 # class Solution { public boolean canWinNim(int n) { return n % 4 != 0; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0326.-Power-of-Three/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0326.-Power-of-Three/</guid>
      <description>0326. Power of Three # 题目 # 给定整数 n，判断它是否为 3 的幂次方。 -2^31 &amp;lt;= n &amp;lt;= 2^31 - 1 思路 # 素因数分解 + 考虑输入范围 # 1162261467 是输入范围 -2^31 &amp;lt;= n &amp;lt;= 2^31 - 1 内最大的 3 的幂次方。 只需判断 n 能否整除 1162261467 即可得知它是否为 3 的幂次方。 1162261467 该值可以通过循环来确定。 代码 # 素因数分解 + 考虑输入范围 # class Solution { public boolean isPowerOfThree(int n) { if (n &amp;lt;= 0) return false; return 1162261467 % n == 0; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0328.-Odd-Even-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0328.-Odd-Even-Linked-List/</guid>
      <description>0328. Odd Even Linked List # 题目 # 给定单链表头节点head，将所有索引为奇数的节点和所有索引为偶数的节点分别组合在一起，然后返回重新排序的链表。
第一个节点的索引被认为是奇数，第二个节点的索引被认为是偶数，以此类推。
偶数组和奇数组内部的相对顺序应该与输入时保持一致。
需要在O(1)的额外空间复杂度和O(n)的时间复杂度下解决这个问题。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode oddEvenList(ListNode head) { if (head == null || head.next == null) return head; ListNode Odd = head, Even = head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0338.-Counting-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0338.-Counting-Bits/</guid>
      <description> 338. Counting Bits # 题目 # 给定一个整数 n，对于 0 &amp;lt;= i &amp;lt;= n 中的每个 i，计算其二进制表示中 1 的个数，返回一个长度为 n+1 的数组 ans 作为答案。
思路 # 右移计数 Brian Kernighan 代码 # 右移计数 # class Solution { public int count(int num) { int result = 0; for (int i = 30; i &amp;gt;= 0; i--) { if (((num &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) result += 1; } return result; } public int[] countBits(int n) { int[] ans = new int[n + 1]; for (int i = 0; i &amp;lt;= n; i++) { ans[i] = count(i); } return ans; } } Brian Kernighan # class Solution { public int count(int num) { int ans = 0; while (num &amp;gt; 0) { num &amp;amp;= num - 1; ans += 1; } return ans; } public int[] countBits(int n) { int[] ans = new int[n + 1]; for(int i = 0; i &amp;lt;= n; i++) ans[i] = count(i); return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0342.-Power-of-Four/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0342.-Power-of-Four/</guid>
      <description> 342. Power of Four # 题目 # 给定一个整数，判断它是否是 4 的幂次方。
思路 # 某个整数是 4 的幂次需要满足三个条件:
正数 二进制表示中只含有一位 1 二进制表示中最高位 1 所在比特位为偶数 代码 # class Solution { public boolean isPowerOfFour(int n) { if (n &amp;lt;= 0) return false; boolean found = false; for (int i = 31; i &amp;gt;= 0; i--) { if (((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) { if ((i &amp;amp; 1) == 1 || found == true) return false; found = true; } } return true; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0344.-Reverse-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0344.-Reverse-String/</guid>
      <description> 0344. Reverse String # 题目 # 编写一个函数，将输入的字符串翻转过来。字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，原地修改输入数组，使用 O(1) 的额外空间解决这一问题。
思路 # 双指针 # 代码 # 双指针 # class Solution { public void reverseString(char[] s) { for (int i=0, j=s.length-1; i&amp;lt;j; i++, j--) { char temp = s[i]; s[i] = s[j]; s[j] = temp; } } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0345.-Reverse-Vowels-of-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0345.-Reverse-Vowels-of-a-String/</guid>
      <description>0345. Reverse Vowels of a String # 题目 # 给定字符串 s，反转其中的所有元素字母，并返回字符串。 元音字母包含 &#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39; 及其大写形式。 思路 # 双指针 # 代码 # 双指针 （StringBuilder） # class Solution { boolean isVowel(Character ch) { if (ch == &amp;#39;a&amp;#39; || ch == &amp;#39;e&amp;#39; || ch == &amp;#39;i&amp;#39; || ch == &amp;#39;o&amp;#39; || ch == &amp;#39;u&amp;#39;) return true; if (ch == &amp;#39;A&amp;#39; || ch == &amp;#39;E&amp;#39; || ch == &amp;#39;I&amp;#39; || ch == &amp;#39;O&amp;#39; || ch == &amp;#39;U&amp;#39;) return true; return false; } public String reverseVowels(String s) { int i = 0, j = s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0349.-Intersection-of-Two-Arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0349.-Intersection-of-Two-Arrays/</guid>
      <description>349. Intersection of Two Arrays # 题目 # 给定两个数组 nums1 和 nums2，返回 它们的交集。输出结果中的每个元素一定是 唯一 的。不考虑输出结果的顺序。
思路 # 代码 # class Solution { public int[] intersection(int[] nums1, int[] nums2) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int num: nums1) set.add(num); List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int num: nums2) { if (set.contains(num) == true) { list.add(num); set.remove(num); } } int[] result = new int[list.size()]; for (int i=0; i&amp;lt;list.size(); i++) result[i] = list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0355.-Design-Twitter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0355.-Design-Twitter/</guid>
      <description>355. Design Twitter # 题目 # 设计一个简化版的推特，让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 10 条推文。
实现 Twitter 类：
Twitter() 初始化简易版推特对象 void postTweet(int userId, int tweetId) 根据给定的 tweetId 和 userId 创建一条新推文。每次调用此函数都会使用一个不同的 tweetId。 List&amp;lt;Integer&amp;gt; getNewsFeed(int userId) 检索当前用户新闻推送中最近 10 条推文的 ID。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 按照时间顺序由最近到最远排序。 void follow(int followerId, int followeeId) ID 为 followerId 的用户开始关注 ID 为 followeeId 的用户。 void unfollow(int followerId, int followeeId) ID 为 followerId 的用户不再关注 ID 为 followeeId 的用户。 思路 # 哈希表 存储用户的关注列表。 单链表 存储用户的推文链表。 优先级队列 实现按时间戳排序的推文链表的合并。 大顶堆 实现最近 N 条推文的获取。 代码 # class Twitter { private class ListNode implements Comparable&amp;lt;ListNode&amp;gt; { public int timestamp; public int tweetId; public ListNode next; ListNode(int timestamp, int tweetId, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0369.-Plus-One-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0369.-Plus-One-Linked-List/</guid>
      <description>369. Plus One Linked List # 题目 # 给定一个用 链表 表示的非负整数，然后将这个整数加一。
最高位有效数字位于链表的首尾 head。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public int helper(ListNode head, int carry) { if (head.next == null) { int result = (head.val + carry) / 10; head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0374.-Guess-Number-Higher-or-Lower/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0374.-Guess-Number-Higher-or-Lower/</guid>
      <description> 0374. Guess Number Higher or Lower # 题目 # 猜数字游戏 规则如下： 从 1 到 n 随机选择一个数字。 猜出被选择的这个数字。 guess 函数会返回所猜数字与所选数字的大小关系。 -1：所选数字小于所猜数字 1：所选数字大于所猜数字 0：所选数字等于所猜数字 返回所选数字。 思路 # 二分 # 代码 # 二分 # /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is higher than the picked number *	1 if num is lower than the picked number * otherwise return 0 * int guess(int num); */ public class Solution extends GuessGame { public int guessNumber(int n) { int left = 1, right = n; while (left &amp;lt;= right) { int mid = left + (right - left) / 2; if (guess(mid) == 0) return mid; else if (guess(mid) == -1) right = mid - 1; else left = mid + 1; } return -1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0379.-Design-Phone-Directory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0379.-Design-Phone-Directory/</guid>
      <description>379. Design Phone Directory # 题目 # 设计一个电话目录管理系统，令其支持以下功能：
get： 分配给用户一个未被使用的电话号码，获取失败时返回 -1 check：检查指定的电话号码是否被使用 release：释放掉一个电话号码，使其能够重新被分配 思路 # 代码 # class PhoneDirectory { private class ListNode { int val; ListNode prev; ListNode next; ListNode(int val, ListNode prev, ListNode next) { this.val = val; this.prev = prev; this.next = next; } } private ListNode sentinel; private Map&amp;lt;Integer, ListNode&amp;gt; map; /** 记录电话号码 number 是否被分配 */ public PhoneDirectory(int maxNumbers) { this.sentinel = new ListNode(-1, null, null); this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0382.-Linked-List-Random-Node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0382.-Linked-List-Random-Node/</guid>
      <description>382. Linked List Random Node # 题目 # 给定单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点被选中的概率一样。
考虑处理以下情形：
链表非常大且长度未知 使用O(1)的额外空间复杂度 思路 # 使用 蓄水池抽样算法 以O(n)的时间复杂度和O(1)的空间复杂度解决此问题。
代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { private Random rand; private ListNode sentinel; public Solution(ListNode head) { this.rand = new Random(); this.sentinel = new ListNode(-1, head); } public int getRandom() { ListNode ptr = this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0383.-Ransom-Note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0383.-Ransom-Note/</guid>
      <description> 383. Ransom Note # 题目 # 给定两个字符串: ransomNote 和 magazine，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true，否则返回 false。
magazine 中的每个字符只能在 ransomNote 中使用一次。
思路 # 代码 # class Solution { public boolean canConstruct(String ransomNote, String magazine) { if (ransomNote.length() &amp;gt; magazine.length()) return false; int[] count = new int[26]; for(int i=0; i&amp;lt;magazine.length(); i++) count[magazine.charAt(i)-&amp;#39;a&amp;#39;] += 1; for(int i=0; i&amp;lt;ransomNote.length(); i++) { if (count[ransomNote.charAt(i)-&amp;#39;a&amp;#39;] == 0) return false; count[ransomNote.charAt(i)-&amp;#39;a&amp;#39;] -= 1; } return true; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0387.-First-Unique-Character-in-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0387.-First-Unique-Character-in-a-String/</guid>
      <description> 387. First Unique Character in a String # 题目 # 给定一个字符串 s，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
思路 # 代码 # class Solution { public int firstUniqChar(String s) { int[] seen = new int[26]; for (int i = 0; i &amp;lt; s.length(); i++) seen[s.charAt(i) - &amp;#39;a&amp;#39;] += 1; for (int i = 0; i &amp;lt; s.length(); i++) if (seen[s.charAt(i) - &amp;#39;a&amp;#39;] == 1) return i; return -1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0389.-Find-the-Difference/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0389.-Find-the-Difference/</guid>
      <description> 389. Find the Difference # 题目 # 给定两个字符串 s 和 t，它们只包含小写字母。
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。
找出在 t 中被添加的字母。
思路 # 代码 # class Solution { public char findTheDifference(String s, String t) { char res = 0; for (int i = 0; i &amp;lt; s.length(); i++) res ^= s.charAt(i); for (int i = 0; i &amp;lt; t.length(); i++) res ^= t.charAt(i); return res; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0392.-Is-Subsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0300-to-0399/0392.-Is-Subsequence/</guid>
      <description> 0392. Is Subsequence # 题目 # 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 （例如，&amp;quot;ace&amp;quot;是&amp;quot;abcde&amp;quot;的一个子序列，而&amp;quot;aec&amp;quot;不是）。 思路 # 代码 # class Solution { public boolean isSubsequence(String s, String t) { int i = 0, j = 0; while (i &amp;lt; s.length() &amp;amp;&amp;amp; j &amp;lt; t.length()) { if (s.charAt(i) == t.charAt(j)) i++; j++; } return i == s.length(); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0405.-Convert-a-Number-to-Hexadecimal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0405.-Convert-a-Number-to-Hexadecimal/</guid>
      <description>0405. Convert a Number to Hexadecimal # 题目 # 给定一个整数，将这个数转换为十六进制数。 对于负整数，通常使用补码运算方式。 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符&#39;0&#39;来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String int2hex(int num) { switch (num) { case 0x00000000 : return &amp;#34;0&amp;#34;; case 0x10000000 : return &amp;#34;1&amp;#34;; case 0x20000000 : return &amp;#34;2&amp;#34;; case 0x30000000 : return &amp;#34;3&amp;#34;; case 0x40000000 : return &amp;#34;4&amp;#34;; case 0x50000000 : return &amp;#34;5&amp;#34;; case 0x60000000 : return &amp;#34;6&amp;#34;; case 0x70000000 : return &amp;#34;7&amp;#34;; case 0x80000000 : return &amp;#34;8&amp;#34;; case 0x90000000 : return &amp;#34;9&amp;#34;; case 0xa0000000 : return &amp;#34;a&amp;#34;; case 0xb0000000 : return &amp;#34;b&amp;#34;; case 0xc0000000 : return &amp;#34;c&amp;#34;; case 0xd0000000 : return &amp;#34;d&amp;#34;; case 0xe0000000 : return &amp;#34;e&amp;#34;; case 0xf0000000 : return &amp;#34;f&amp;#34;; } return &amp;#34;&amp;#34;; } public String toHex(int num) { if (num == 0) return &amp;#34;0&amp;#34;; boolean flag = false; String ans = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; 8; i++) { int and = num &amp;amp; 0xf0000000; if (and !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0412.-Fizz-Buzz/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0412.-Fizz-Buzz/</guid>
      <description>0412. Fizz Buzz # 题目 # 给定整数 n ，找出 1 至 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：
answer[i] == &amp;quot;FizzBuzz&amp;quot; 如果 i 同时是 3 和 5 的倍数。
answer[i] == &amp;quot;Fizz&amp;quot; 如果 i 是 3 的倍数。
answer[i] == &amp;quot;Buzz&amp;quot; 如果 i 是 5 的倍数。
answer[i] == i （以字符串形式）如果上述条件全不满足。
思路 # 模拟 # 代码 # 模拟 # class Solution { public List&amp;lt;String&amp;gt; fizzBuzz(int n) { List&amp;lt;String&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); for (int i = 1; i &amp;lt;= n; i++) { if (i % 3 == 0 &amp;amp;&amp;amp; i % 5 == 0) ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0414.-Third-Maximum-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0414.-Third-Maximum-Number/</guid>
      <description>0414. Third Maximum Number # 题目 # 给定一个非空数组，返回该数组中 第三大的数。 如果不存在，则返回数组中最大的数。 注: 要求返回第三大的数，是指在所有不同数字中排第三大的数。 思路 # 模拟 + 哈希 # 代码 # 模拟 + 哈希 # class Solution { public int thirdMax(int[] nums) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); int first = Integer.MIN_VALUE, second = Integer.MIN_VALUE, third = Integer.MIN_VALUE; for (int num: nums) { if (set.contains(num) == false) { if (set.size() == 0) first = num; else if (set.size() == 1) { second = first &amp;gt; num ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0429.-N-ary-Tree-Level-Order-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0429.-N-ary-Tree-Level-Order-Traversal/</guid>
      <description>0429. N-ary Tree Level Order Traversal # 题目 # 给定一个 N 叉树，返回其节点的 层序遍历。
思路 # 代码 # class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _ children; } } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(Node root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0430.-Flatten-a-Multilevel-Doubly-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0430.-Flatten-a-Multilevel-Doubly-Linked-List/</guid>
      <description>430. Flatten a Multilevel Doubly Linked List # 题目 # 给定一个双链表，各节点有一个 next 指针、一个 prev 指针和一个的 child 指针 。这个 child 指针 可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，从而构成 多层数据结构 。
给定链表的头节点 head ，将链表 扁平化 ，使所有节点都出现在单层双链表中。让 curr 是一个带有子列表的节点。子列表中的节点应该出现在扁平化列表中的 curr 之后 和 curr.next 之前 。
返回 扁平列表的 head 。列表中的节点必须将其 所有 子指针设置为 null 。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0432.-All-O1-Data-Structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0432.-All-O1-Data-Structure/</guid>
      <description>432. All O(1) Data Structure # 题目 # 设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。
实现 AllOne 类：
AllOne() 初始化数据结构的对象。 inc(String key) 字符串 key 的计数增加 1 。如果数据结构中尚不存在 key ，那么插入计数为 1 的 key 。 dec(String key) 字符串 key 的计数减少 1 。如果 key 的计数在减少后为 0 ，那么需要将这个 key 从数据结构中删除。测试用例保证：在减少计数前，key 存在于数据结构中。 getMaxKey() 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 &amp;quot;&amp;quot; 。 getMinKey() 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 &amp;quot;&amp;quot; 。 **注意：**每个函数都应当满足 O(1) 平均时间复杂度。
思路 # 采用 双向链表 + 哈希表 的方式实现。 链表结点记录 频率 以及 该频率对应的字符串集合，以 Max &amp;lt;&amp;ndash;&amp;gt; Min 的顺序存储。 HashSet 可以在 O(1) 的时间复杂度内实现 add 和 remove 操作。 代码 # class AllOne { private class ListNode { public int count; public Set&amp;lt;String&amp;gt; collection; public ListNode prev; public ListNode next; ListNode(int count, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0434.-Number-of-Segments-in-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0434.-Number-of-Segments-in-a-String/</guid>
      <description> 0434. Number of Segments in a String # 题目 # 统计字符串中的单词个数，这里的单词指的是连续的非空格的字符。 假定字符串不包括任何不可打印的字符。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int countSegments(String s) { if (s.length() == 0) return 0; int ans = s.charAt(0) == &amp;#39; &amp;#39; ? 0 : 1, ptr = 0; while (ptr &amp;lt; s.length() - 1) { if (s.charAt(ptr) == &amp;#39; &amp;#39; &amp;amp;&amp;amp; s.charAt(ptr + 1) != &amp;#39; &amp;#39;) { ans++; ptr += 2; } else ptr++; } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0441.-Arranging-Coins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0441.-Arranging-Coins/</guid>
      <description> 0441. Arranging Coins # 题目 # 共有 n 枚硬币，将它们按阶梯状排列。 对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。 给定数字 n，计算并返回可形成 完整阶梯行 的总行数。 1 &amp;lt;= n &amp;lt;= 2^31 - 1 思路 # 二分查找 # 代码 # 二分查找 # class Solution { public long capacity(int k) { return (long) k * (k + 1) / 2; } public int arrangeCoins(int n) { /** left 表示已知能填充满的最大行数, right 是已知不能填充满的最小行数 */ int left = 1, right = n; while (left &amp;lt; right - 1) { int mid = left + (right - left) / 2; if (capacity(mid) == n) return mid; else if (capacity(mid) &amp;gt; n) right = mid; else left = mid; } return left; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0445.-Add-Two-Numbers-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0445.-Add-Two-Numbers-ii/</guid>
      <description>445. Add Two Numbers II # 题目 # 给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public int helper(ListNode l1, ListNode l2) { if (l1.next == null &amp;amp;&amp;amp; l2.next == null) { int carry = (l1.val + l2.val) / 10; l1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0448.-Find-All-Numbers-Disappeared-in-an-Arry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0448.-Find-All-Numbers-Disappeared-in-an-Arry/</guid>
      <description>0448. Find All Numbers Disappeared in an Array # 题目 # 给定一个含 n 个整数的数组 nums，其中 nums[i] 在区间 [1, n] 内。找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。
思路 # 原地哈希 代码 # class Solution { public List&amp;lt;Integer&amp;gt; findDisappearedNumbers(int[] nums) { for (int num: nums) { if (nums[Math.abs(num) - 1] &amp;gt; 0) nums[Math.abs(num) - 1] *= -1; } List&amp;lt;Integer&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] &amp;gt; 0) ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0455.-Assign-Cookies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0455.-Assign-Cookies/</guid>
      <description>0455. Assign Cookies # 题目 # 为孩子们分配饼干，每个孩子最多只能给一块饼干。 孩子 i 对应胃口值 g[i]。饼干 j 对应尺寸 s[j]。若 s[j] &amp;gt;= g[i]，则饼干 j 可以令孩子 i 满足。 尽可能满足最多数量的孩子，并返回这个最大数值。 思路 # 排序+双指针+贪心 代码 # 排序+双指针+贪心 # class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int i = 0, j = 0; while (i &amp;lt; g.length &amp;amp;&amp;amp; j &amp;lt; s.length) { while (j &amp;lt; s.length &amp;amp;&amp;amp; g[i] &amp;gt; s[j]) j += 1; if (j++ &amp;lt; s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0460.-LFU-Cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0460.-LFU-Cache/</guid>
      <description>460. LFU Cache # 题目 # 为 最不经常使用（LFU）缓存算法设计并实现数据结构。
实现 LFUCache 类：
LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。 void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。 为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。
当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
思路 # 代码 # class LFUCache { private class ListNode { public int key; public int frequency; public int val; public ListNode prev; public ListNode next; ListNode(int key, int value, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0461.-Hamming-Distance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0461.-Hamming-Distance/</guid>
      <description> 461. Hamming Distance # 题目 # 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
给定两个整数 x 和 y，计算并返回它们之间的汉明距离。
思路 # 异或 + 统计 1 的数目
代码 # 汉明距离 # class Solution { public int hammingDistance(int x, int y) { int sum = x ^ y; int hammingDistance = 0; for (int i=31; i&amp;gt;=0; i--) { if (((sum &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) hammingDistance += 1; } return hammingDistance; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0476.-Number-Complement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0476.-Number-Complement/</guid>
      <description> 476. Number Complement # 题目 # 对整数的二进制表示取反 (0 变 1，1 变 0) 后，再转换为十进制表示，可以得到这个整数的补数。
如整数 5 的二进制表示是 &amp;quot;101&amp;quot;，取反后得到 &amp;quot;010&amp;quot;，再转回十进制表示得到补数 2。
给定一个整数，输出其补数。
注: 1 &amp;lt;= num &amp;lt; 2^31
思路 # 代码 # class Solution { public int findComplement(int num) { if (num == 0) return 1; boolean flag = false; for (int i = 30; i &amp;gt;= 0; i--) { if (((num &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) flag = true; if (flag == true) { num ^= 1 &amp;lt;&amp;lt; i; } } return num; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0482.-License-Key-Formatting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0482.-License-Key-Formatting/</guid>
      <description>0482. License Key Formatting # 题目 # 给定许可密钥字符串 s，仅由字母、数字字符和破折号组成。字字符串由 n 个破折号分成 n+1组。 给定整数 k 以重新格式化字符串，使每一组包含 k 个字符。 第一组可以比 k 短，但仍必须包含至少一个字符。 两组之间需要插入破折号，且应该将所有小写字母转换为大写字母。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String licenseKeyFormatting(String s, int k) { /** 遍历 s, 确定格式化后的密钥长度 */ int numLetterOrDigits = 0; for (int i = 0; i &amp;lt; s.length(); i++) { if (Character.isLetterOrDigit(s.charAt(i))) numLetterOrDigits++; } int sz = numLetterOrDigits; if (sz == 0) return &amp;#34;&amp;#34;; sz += numLetterOrDigits % k == 0 ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0485.-Max-Consecutive-Ones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0485.-Max-Consecutive-Ones/</guid>
      <description> 0485. Max Consecutive Ones # 题目 # 给定二进制数组 nums，计算其中最大连续 1 的个数。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int findMaxConsecutiveOnes(int[] nums) { int ans = 0, cnt = 0; for (int num: nums) { if (num == 0) cnt = 0; else ans = Math.max(ans, ++cnt); } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0495.-Teemo-Attacking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0400-to-0499/0495.-Teemo-Attacking/</guid>
      <description>495. Teemo Attacking # 题目 # 在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。
当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。
正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。
给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。
返回艾希处于中毒状态的 总 秒数。
思路 # 代码 # class Solution { public int findPoisonedDuration(int[] timeSeries, int duration) { int lasting = 0; for (int i = 0; i &amp;lt; timeSeries.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0500.-Keyboard-Row/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0500.-Keyboard-Row/</guid>
      <description>0500. Keyboard Row # 题目 # 给定字符串数组 words ，返回可以使用在 美式键盘 同一行的字母打印出来的单词。 美式键盘 中： 第一行由字符 &amp;quot;qwertyuiop&amp;quot; 组成。 第二行由字符 &amp;quot;asdfghjkl&amp;quot; 组成。 第三行由字符 &amp;quot;zxcvbnm&amp;quot; 组成。 思路 # 模拟+打表 # 代码 # 模拟+打表 # class Solution { public void mapping (int[] qwerty) { qwerty[&amp;#39;q&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;w&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;e&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;r&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;t&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;y&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;u&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;i&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;o&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;p&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;a&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;s&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;d&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;f&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;g&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;h&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;j&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;k&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;l&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;z&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;x&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;c&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;v&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;b&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;n&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;m&amp;#39;-&amp;#39;a&amp;#39;] = 2; } public String[] findWords(String[] words) { int[] qwerty = new int[26]; mapping(qwerty); List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for (String word: words) { boolean ok = true; for (int i = 0; i &amp;lt; word.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0506.-Relative-Ranks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0506.-Relative-Ranks/</guid>
      <description>0506. Relative Ranks # 题目 # 给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。 运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况： 名次第 1 的运动员获金牌 &amp;quot;Gold Medal&amp;quot; 。 名次第 2 的运动员获银牌 &amp;quot;Silver Medal&amp;quot; 。 名次第 3 的运动员获铜牌 &amp;quot;Bronze Medal&amp;quot; 。 从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 &amp;quot;x&amp;quot;）。 使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String[] findRelativeRanks(int[] score) { String[] ans = new String[score.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0507.-Perfect-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0507.-Perfect-Number/</guid>
      <description>0507. Perfect Number # 题目 # 对于一个 正整数，如果它除了和它自身以外的所有 正因子 之和相等，称它为 「完美数」。 给定一个 整数 n，如果是完美数，返回 true；否则返回 false。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean checkPerfectNumber (int num) { if (num == 1) return false; int sum = 1; for (int i = 2; i &amp;lt; Math.sqrt((double) num); i++) { if (num % i == 0) { sum += i == num / i ? i : i + num / i; } } return sum == num; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0513.-Find-Bottom-Left-Tree-Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0513.-Find-Bottom-Left-Tree-Value/</guid>
      <description>0513. Find Bottom Left Tree Value # 题目 # 给定一棵二叉树的 根节点 root，找出该二叉树的 最底层 最左边 节点的值。
假定二叉树至少有一个节点。
思路 # 层数遍历 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int findBottomLeftValue(TreeNode root) { int ans = root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0515.-Find-Largest-Value-in-Each-Tree-Row/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0515.-Find-Largest-Value-in-Each-Tree-Row/</guid>
      <description>515. Find Largest Value in Each Tree Row # 题目 # 给定一棵二叉树的根节点 root，找出该二叉树中每一层的最大值。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;Integer&amp;gt; largestValues(TreeNode root) { List&amp;lt;Integer&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0520.-Detect-Capital/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0520.-Detect-Capital/</guid>
      <description>0520. Detect Capital # 题目 # 定义单词的大写用法的正确使用情景为：
全部字母都是大写，比如 &amp;quot;USA&amp;quot; 。 单词中所有字母都不是大写，比如 &amp;quot;leetcode&amp;quot; 。 如果单词不只含有一个字母，只有首字母大写， 比如 &amp;quot;Google&amp;quot; 。 给定字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。
思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean detectCapitalUse(String word) { int cnt = 0; for (int i = 0; i &amp;lt; word.length(); i++) { if (Character.isUpperCase(word.charAt(i))) cnt++; } return cnt == word.length() || cnt == 0 || (cnt == 1 &amp;amp;&amp;amp; Character.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0537.-Complex-Number-Multiplication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0537.-Complex-Number-Multiplication/</guid>
      <description>0537. Complex Number Multiplication # 题目 # 复数 可以用字符串表示，遵循 &amp;quot;**实部**+**虚部**i&amp;quot; 的形式，并满足下述条件： 实部 是一个整数，取值范围是 [-100, 100] 虚部 也是一个整数，取值范围是 [-100, 100] i2 == -1 给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。 思路 # 模拟 # 正则 # 代码 # 模拟 # class Solution { /** (a + bj)(c + dj) = (ac - bd) + (ad + bc) j */ public String[] parseComplex(String num) { String real = &amp;#34;&amp;#34;, imag = &amp;#34;&amp;#34;; boolean imagFlag = false; char[] charArray = num.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0541.-Reverse-String-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0541.-Reverse-String-ii/</guid>
      <description>541. Reverse String II # 题目 # 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 思路 # 代码 # class Solution { public void reversePart(char[] charArray, int left, int right) { while (left &amp;lt; right) { char temp = charArray[left]; charArray[left] = charArray[right]; charArray[right] = temp; left += 1; right -= 1; } } public String reverseStr(String s, int k) { char[] charArray = s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0551.-Student-Attendance-Record-i/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0551.-Student-Attendance-Record-i/</guid>
      <description>0551. Student Attendance Record I # 题目 # 给定表示学生出勤记录的字符串 s ，每个字符用于标记当天的出勤情况。
记录中只含下面三种字符：
&#39;A&#39;：Absent，缺勤 &#39;L&#39;：Late，迟到 &#39;P&#39;：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
按 总出勤 计，学生缺勤（&#39;A&#39;）严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&#39;L&#39;）记录。 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean checkRecord(String s) { int numAbsent = 0, numLate = 0; for (int i = 0; i &amp;lt; s.length(); i++) { if (s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0557.-Reverse-Words-in-a-String-iii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0557.-Reverse-Words-in-a-String-iii/</guid>
      <description>0557. Reverse Words in a String iii # 题目 # 给定字符串 s，反转字符串中每个单词的字符顺序，同时保留空格和单词的初始顺序。 思路 # 双指针 # 代码 # 双指针 # class Solution { public String reverseWords(String s) { String[] words = s.split(&amp;#34; &amp;#34;); for (int i = 0; i &amp;lt; words.length; i++) { char[] charArray = words[i].toCharArray(); int left = 0, right = charArray.length - 1; while (left &amp;lt; right) { char temp = charArray[left]; charArray[left] = charArray[right]; charArray[right] = temp; left++; right--; } words[i] = String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0559.-Maximum-Depth-of-N-ary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0559.-Maximum-Depth-of-N-ary-Tree/</guid>
      <description>0559. Maximum Depth of N-ary Tree # 题目 # 给定一个 n 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
思路 # 层序遍历 代码 # class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } } class Solution { public int maxDepth(Node root) { if (root == null) return 0; int depth = 0; Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0563.-Binary-Tree-Tilt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0563.-Binary-Tree-Tilt/</guid>
      <description>0563. Binary Tree Tilt # 题目 # 给定二叉树根节点 root ，计算并返回 整个树 的坡度 。 一个树的 节点的坡度 定义为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。 整个树 的坡度是其所有节点的坡度之和。 思路 # 递归 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int sum(TreeNode root, List&amp;lt;Integer&amp;gt; tilt) { if (root == null) return 0; int leftSum = sum(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0566.-Reshape-the-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0566.-Reshape-the-Matrix/</guid>
      <description> 0566. Reshape the Matrix # 题目 # 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 思路 # 代码 # class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int M = mat.length, N = mat[0].length; if (M * N != r * c) return mat; int[][] ans = new int[r][c]; for (int i = 0; i &amp;lt; r; i++) { for (int j = 0; j &amp;lt; c; j++) { int index = i * c + j; int mIndex = index / N, nIndex = index % N; ans[i][j] = mat[mIndex][nIndex]; } } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0575.-Distribute-Candies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0575.-Distribute-Candies/</guid>
      <description> 0575. Distribute Candies # 题目 # Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。 医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。 给你一个长度为 n 的整数数组 candyType，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的 最多 种类数。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int distributeCandies(int[] candyType) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for(int type: candyType) set.add(type); return Math.min(set.size(), candyType.length / 2); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0589.-N-ary-Tree-Preorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0589.-N-ary-Tree-Preorder-Traversal/</guid>
      <description>589. N-ary Tree Preorder Traversal # 题目 # 给定一个 n 叉树的根节点 root，返回其节点值的 前序遍历。
思路 # 递归 迭代 代码 # 递归 # class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } } class Solution { public void traversal(Node root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0590.-N-ary-Tree-Postorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0590.-N-ary-Tree-Postorder-Traversal/</guid>
      <description>590. N-ary Tree Postorder Traversal # 题目 # 给定一个 n 叉树的根节点 root，返回其节点值的 后序遍历。
思路 # 递归 迭代 代码 # 递归 # class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } } class Solution { public void traversal(Node root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; for (Node child: root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0594.-Longest-Harmonious-Subsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0594.-Longest-Harmonious-Subsequence/</guid>
      <description>0594. Longest Harmonious Subsequence # 题目 # 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。 现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。 思路 # 模拟 # 滑动窗口 # 代码 # 模拟 # class Solution { public int findLHS(int[] nums) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int num: nums) map.put(num, map.getOrDefault(num, 0) + 1); int ans = 0; for (int num: nums) { if (map.containsKey(num-1)) ans=Math.max(ans, map.get(num-1)+map.get(num)); } return ans; } } 迭代 # 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0598.-Range-Addition-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0598.-Range-Addition-II/</guid>
      <description>0598. Range Addition II # 题目 # 给你一个 m x n 的矩阵 M ，初始化时所有的 0 和一个操作数组 op ，其中 ops[i] = [ai, bi] 意味着当所有的 0 &amp;lt;= x &amp;lt; ai 和 0 &amp;lt;= y &amp;lt; bi 时， M[x][y] 应该加 1。 在 执行完所有操作后 ，计算并返回 矩阵中最大整数的个数 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int maxCount(int m, int n, int[][] ops) { int[] ans = new int[]{m, n}; for (int[] op: ops) { ans[0] = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0599.-Minimum-Index-Sum-of-Two-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0599.-Minimum-Index-Sum-of-Two-Lists/</guid>
      <description>0599. Minimum Index Sum of Two Lists # 题目 # 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String[] findRestaurant(String[] list1, String[] list2) { int indexSum = Integer.MAX_VALUE; List&amp;lt;String&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; list1.length; i++) map.put(list1[i], i); for (int i = 0; i &amp;lt; list2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0617.-Merge-Two-Binary-Trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0617.-Merge-Two-Binary-Trees/</guid>
      <description>617. Merge Two Binary Trees # 题目 # 给定两棵二叉树 root1 和 root2。
想象一下，当泥浆其中一棵覆盖到另一棵上时，两棵树上的一些节点将会重叠（而另一些不会）。需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。
返回合并后的二叉树。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode (int val) { this.val = val; } TreeNode (int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; root1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0622.-Design-Circular-Queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0622.-Design-Circular-Queue/</guid>
      <description>622. Design Circular Queue # 题目 # 设计循环队列。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
你的实现应该支持如下操作：
MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 思路 # 基于链表的实现较为简单，而基于数组的实现相对复杂。
代码 # class MyCircularQueue { private class ListNode { int val; ListNode prev; ListNode next; ListNode (int val, ListNode prev, ListNode next) { this.val = val; this.prev = prev; this.next = next; } } private int size; private int capacity; ListNode sentinel; public MyCircularQueue(int k) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0637.-Average-of-Levels-in-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0637.-Average-of-Levels-in-Binary-Tree/</guid>
      <description>637. Average of Levels in Binary Tree # 题目 # 给定一个非空二叉树的根节点 root，以数组的形式返回每一层节点的平均值。
与实际答案相差 10^-5 以内的答案可以被接受。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode (int val) { this.val = val; } TreeNode (int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;Double&amp;gt; averageOfLevels(TreeNode root) { List&amp;lt;Double&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0641.-Design-Circular-Deque/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0641.-Design-Circular-Deque/</guid>
      <description>641. Design Circular Deque # 题目 # 设计实现双端队列。
实现 MyCircularDeque 类:
MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。 boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。 boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。 boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。 boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。 int getFront() )：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。 int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。 boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false 。 boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。 思路 # 代码 # class MyCircularDeque { private class ListNode { public int val; public ListNode prev; public ListNode next; ListNode (int value, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0643.-Maximum-Average-Subarray-i/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0643.-Maximum-Average-Subarray-i/</guid>
      <description>0643. Maximum Average Subarray i # 题目 # 给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10^-5 的答案都将被视为正确答案。 思路 # 模拟 # 代码 # 模拟 # class Solution { public double findMaxAverage(int[] nums, int k) { int ans = 0, windowSum = 0; for (int i = 0; i &amp;lt; k; i++) windowSum += nums[i]; ans = windowSum; int left = 0, right = k - 1; while (right &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0645.-Set-Mismatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0645.-Set-Mismatch/</guid>
      <description> 645. Set Mismatch # 题目 # 集合 s 包含从 1 到 n 的整数。但集合 丢失了一个数字 并 有一个数字重复。
给定数组 nums 代表集合 s 发生错误后的结果。
先找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
思路 # 代码 # class Solution { public int[] findErrorNums(int[] nums) { int[] ans = new int[2]; /** 另 1~n 与 nums 进行异或操作，返回值为 missing ^ duplicate */ int xor = 0; int[] appearance = new int[nums.length]; for (int i = 0; i &amp;lt; nums.length; i++) { xor ^= (i + 1) ^ nums[i]; appearance[nums[i] - 1] += 1; if (appearance[nums[i] - 1] == 2) ans[0] = nums[i]; } /** missing = missing ^ duplicate ^ duplicate */ ans[1] = xor ^ ans[0]; return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0657.-Robot-Return-to-Origin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0657.-Robot-Return-to-Origin/</guid>
      <description>0657. Robot Return to Origin # 题目 # 在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。 如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean judgeCircle(String moves) { if (moves.length() % 2 == 1) return false; int L = 0, R = 0, U = 0, D = 0; for (int i = 0; i &amp;lt; moves.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0661.-Image-Smoother/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0661.-Image-Smoother/</guid>
      <description>0661. Image Smoother # 题目 # 图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。 每个单元格的 平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。 如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。 思路 # 模拟 # 前缀和 # 代码 # 模拟 # class Solution { public int conv(int i, int j, int[][] img) { int M = img.length, N = img[0].length; int numerator = 0, denominator = 0; for (int row = i-1; row &amp;lt;= i+1; row++) { for (int col = j-1; col &amp;lt;= j+1; col++) { if (0 &amp;lt;= row &amp;amp;&amp;amp; row &amp;lt; M &amp;amp;&amp;amp; 0 &amp;lt;= col &amp;amp;&amp;amp; col &amp;lt; N) { numerator += img[row][col]; denominator++; } } } return numerator / denominator; } public int[][] imageSmoother(int[][] img) { int M = img.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0682.-Baseball-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0682.-Baseball-Game/</guid>
      <description>682. Baseball Game # 题目 # 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。
比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：
整数 x - 表示本回合新获得分数 x &amp;quot;+&amp;quot; - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。 &amp;quot;D&amp;quot; - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。 &amp;quot;C&amp;quot; - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。 返回记录中所有得分的总和。
思路 # 栈 代码 # class Solution { public int calPoints(String[] operations) { Stack&amp;lt;Integer&amp;gt; score = new Stack&amp;lt;&amp;gt;(); for (String operation: operations) { if (operation.equals(&amp;#34;+&amp;#34;) == true) { int temp = score.pop(), newVal = temp + score.peek(); score.push(temp); score.push(newVal); } else if (operation.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0693.-Binary-Number-with-Alternating-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0600-to-0699/0693.-Binary-Number-with-Alternating-Bits/</guid>
      <description>693. Binary Number with Alternating Bits # 题目 # 给定一个正整数，检查其二进制表示是否总是 0、1 交替出现。换言之，二进制表示中相邻两位的数字永不相同。
思路 # 代码 # class Solution { public boolean hasAlternatingBits(int n) { /** 先定位最高位的 1 */ int start = 0; for (int i = 30; i &amp;gt;= 0; i--) { if (((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 0) continue; start = i; break; } /** 判断数 n 的二进制表示中相邻两位的数字永不相同 */ for (int i = start - 1, lastBit = ((n &amp;gt;&amp;gt; start) &amp;amp; 1); i &amp;gt;= 0; i--) { if (((n &amp;gt;&amp;gt; i) &amp;amp; 1) == lastBit) return false; lastBit = lastBit = 1 ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0704.-Binary-Search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0704.-Binary-Search/</guid>
      <description> 704. Binary Search # 题目 # 给定一个n个元素有序的升序整型数组nums和一个目标值target，写一个函数搜索nums中的target，如果目标值存在返回下标，否则返回-1。
思路 # 保持consistency不变量。
代码 # class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left &amp;lt; right) { int medium = left + (right - left) / 2; if (nums[medium] == target) return medium; else if (nums[medium] &amp;gt; target) right = medium; else left = medium + 1; } return -1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0707.-Design-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0707.-Design-Linked-List/</guid>
      <description>707. Design Linked List # 题目 # 设计链表的实现。可以选择使用单链表或双链表。
在链表类中实现这些功能：
get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 思路 # 代码 # public class ListNode { public ListNode prev; public ListNode next; public int val; public ListNode(ListNode prev, ListNode next, int val) { this.prev = prev; this.next = next; this.val = val; } } class MyLinkedList { private ListNode sentinel; private int size; public MyLinkedList() { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0708.-Insert-into-a-Sorted-Circular-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0708.-Insert-into-a-Sorted-Circular-Linked-List/</guid>
      <description>708. Insert into a Sorted Circular Linked List # 题目 # 给定 循环单调非递减列表 中的一个点，写一个函数向这个列表中插入一个新元素 interval，使这个列表仍然是循环非降序的。
给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。
如果有多个满足条件的插入位置，可以选择任意一个位置插入心得值，插入后整个列表仍然保持有序。
如果列表为空（给定的节点是 null)，需要创建一个循环有序列表并返回这个节点。否则，返回原先给定的节点。
思路 # 代码 # class Node { public int val; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _next) { val = _val; next = _next; } } class Solution { public boolean canInsert (Node head, int insertVal) { if (head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0709.-To-Lower-Case/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0709.-To-Lower-Case/</guid>
      <description>0709. To Lower Case # 题目 # 给定字符串 s，将该字符串中的大写字母转成相同的小写字母，返回新的字符串。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String toLowerCase(String s) { char[] charArray = s.toCharArray(); for (int i = 0; i &amp;lt; charArray.length; i++) { if (Character.isLetter(charArray[i]) &amp;amp;&amp;amp; charArray[i] &amp;lt; &amp;#39;a&amp;#39;) charArray[i] |= 1 &amp;lt;&amp;lt; 5; } return Stirng.valueOf(charArray); } } 致谢 # 疯子</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0716.-Max-Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0716.-Max-Stack/</guid>
      <description>716. Max Stack # 题目 # 设计一个最大栈数据结构，既支持栈操作，又支持查找栈中最大元素。
实现 MaxStack 类：
MaxStack() 初始化栈对象 void push(int x) 将元素 x 压入栈中 int pop() 移除栈顶元素并返回这个元素 int top() 返回栈顶元素，无需移除 int peekMax() 检索并返回栈中最大元素，无需移除 int popMax() 检索并返回栈中最大元素，并将其移除。如果有多个最大元素，移除 最靠近栈顶 的那个 思路 # Explicit Better Than Implicit 代码 # class MaxStack { private class ListNode implements Comparable&amp;lt;ListNode&amp;gt; { public int index; public int val; public ListNode prev; public ListNode next; ListNode(int index, int val, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0724.-Find-Pivot-Index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0724.-Find-Pivot-Index/</guid>
      <description> 0724. Find Pivot Index # 题目 # 给定整数数组 nums ，计算数组的 中心下标 。 数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。 如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。 如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。 思路 # 前缀和 # 代码 # 前缀和 # class Solution { public int pivotIndex(int[] nums) { int total = 0; for (int num: nums) total += num; int prefix = 0; for (int i = 0; i &amp;lt; nums.length; i++) { if (prefix == total - prefix - nums[i]) return i; prefix += nums[i]; } return -1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0725.-Split-Linked-List-in-Parts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0725.-Split-Linked-List-in-Parts/</guid>
      <description>725. Split Linked List in Parts # 题目 # 给定一个头结点为head的单链表和一个整数k，设计一个算法将链表分隔为k个连续的部分。
每部分的长度应该尽可能相等：任意两部分的长度差距不能超过1，这可能会导致有些部分为null。
这k个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应不小于排在后面的长度。
返回一个由上述k部分组成的数组。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode[] splitListToParts(ListNode head, int k) { /** 1. 确定链表长度 length */ ListNode ptr = head; int length = 0; while (ptr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0735.-Asteroid-Collision/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0735.-Asteroid-Collision/</guid>
      <description>0735. Asteroid Collision # 题目 # 给定一个整数数组 asteroids，表示在同一行的行星。
对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。
找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。
思路 # 栈 # 代码 # 栈 # class Solution { public int[] asteroidCollision(int[] asteroids) { Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (int asteroid: asteroids) { boolean isExist = true; if (stack.size() == 0) stack.push(asteroid); else if (stack.peek() * asteroid &amp;gt; 0) stack.push(asteroid); else if (stack.peek() &amp;lt; 0 &amp;amp;&amp;amp; asteroid &amp;gt; 0) stack.push(asteroid); else while (isExist == true) { if (stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0744.-Find-Smallest-Letter-Greater-Than-Target/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0744.-Find-Smallest-Letter-Greater-Than-Target/</guid>
      <description>0744. Find Smallest Letter Greater Than Target # 题目 # 给定按非递减顺序排序的字符数组 letters 以及一个字符 target。letters 里至少有两个不同的字符。
返回 letters 中大于 target 的最小的字符。如果不存在这样的字符，则返回 letters 的第一个字符。
思路 # 二分 # 代码 # 二分 # class Solution { public char nextGreatestLetter(char[] letters, char target) { int left = 0, right = letters.length; while (left &amp;lt; right) { int mid = left + (right - left) / 2; if (letters[mid] &amp;gt; target) right = mid; else left = mid + 1; } return right == letters.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0746.-Min-Cost-Climbing-Stairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0746.-Min-Cost-Climbing-Stairs/</guid>
      <description>0746. Min Cost Climbing Stairs # 题目 # 给定整数数组 cost，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦支付此费用，即可选择向上爬一个或两个台阶。
可以选择从下标为 0 或 下标为 1 的台阶开始爬楼梯。
计算并返回到达楼梯顶部的最低花费。
思路 # 动态规划 # 定义状态 costs[i] 为由下标为 i 的台阶到达楼梯顶的最小花费。 代码 # 动态规划 # class Solution { public int minCostClimbingStairs(int[] cost) { int nStairs = cost.length; int[] costs = new int[nStairs]; costs[nStairs - 1] = cost[nStairs - 1]; costs[nStairs - 2] = cost[nStairs - 2]; for (int i = nStairs - 3; i &amp;gt; -1; i--) { costs[i] = cost[i] + Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0747.-Largest-Number-At-Least-Twice-of-Others/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0747.-Largest-Number-At-Least-Twice-of-Others/</guid>
      <description>747. Largest Number At Least Twice of Others # 题目 # 给定整数数组 nums ，其中存在 唯一的 最大整数 。
找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。
思路 # 双指针 # 代码 # 双指针 # class Solution { public int dominantIndex(int[] nums) { if (nums.length == 1) return 0; /** 双指针 */ int first = -1, second = -1; if (nums[0] &amp;gt;= nums[1]) { first = 0; second = 1; } else { first = 1; second = 0; } /** 遍历 */ for (int i = 2; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0762.-Prime-Number-of-Set-Bits-in-Binary-Representation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0762.-Prime-Number-of-Set-Bits-in-Binary-Representation/</guid>
      <description> 762. Prime Number of Set Bits in Binary Representation # 题目 # 给定两个整数 left 和 right，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。
计算置位位数 就是二进制表示中 1 的个数。
思路 # 代码 # class Solution { public boolean isPrime(int num) { if (num == 1) return false; for (int i = 2; i &amp;lt;= Math.sqrt(num); i++) { if (num % i == 0) return false; } return true; } public int count(int num) { int count = 0; for (int i = 30; i &amp;gt;= 0; i--) { if (((num &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) count += 1; } return count; } public int countPrimeSetBits(int left, int right) { int numPrime = 0; for (int i = left; i &amp;lt;= right; i++) { int num = count(i); if (isPrime(num) == true) numPrime += 1; } return numPrime; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0771.-Jewels-and-Stones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0771.-Jewels-and-Stones/</guid>
      <description> 0771. Jewels and Stones # 题目 # 给定字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 字母区分大小写，因此 &amp;quot;a&amp;quot; 和 &amp;quot;A&amp;quot; 是不同类型的石头。 思路 # 哈希 # 代码 # 哈希 # class Solution { public int numJewelsInStones(String jewels, String stones) { Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; jewels.length(); i++) set.add(jewels.charAt(i)); int ans = 0; for (int i = 0; i &amp;lt; stones.length(); i++) if (set.contains(stones.charAt(i))) ans++; return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0796.-Rotate-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0700-to-0799/0796.-Rotate-String/</guid>
      <description>0796. Rotate String # 题目 # 给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。
s 的 旋转操作 就是将 s 最左边的字符移动到最右边。
例如, 若 s = &#39;abcde&#39;，在旋转一次之后结果就是&#39;bcdea&#39; 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String rotate(String s) { String ans = &amp;#34;&amp;#34;; for (int i = 1; i &amp;lt; s.length(); i++) ans += String.valueOf(s.charAt(i)); ans += String.valueOf(s.charAt(0)); return ans; } public boolean rotateString(String s, String goal) { if (s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0804.-Unique-Morse-Code-Words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0804.-Unique-Morse-Code-Words/</guid>
      <description>0804. Unique Morse Code Words # 题目 # 国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:
&#39;a&#39; 对应 &amp;quot;.-&amp;quot; ， &#39;b&#39; 对应 &amp;quot;-...&amp;quot; ， &#39;c&#39; 对应 &amp;quot;-.-.&amp;quot; ，以此类推。 为了方便，所有 26 个英文字母的摩尔斯密码表如下：
[&amp;#34;.-&amp;#34;,&amp;#34;-...&amp;#34;,&amp;#34;-.-.&amp;#34;,&amp;#34;-..&amp;#34;,&amp;#34;.&amp;#34;,&amp;#34;..-.&amp;#34;,&amp;#34;--.&amp;#34;,&amp;#34;....&amp;#34;,&amp;#34;..&amp;#34;,&amp;#34;.---&amp;#34;,&amp;#34;-.-&amp;#34;,&amp;#34;.-..&amp;#34;,&amp;#34;--&amp;#34;,&amp;#34;-.&amp;#34;,&amp;#34;---&amp;#34;,&amp;#34;.--.&amp;#34;,&amp;#34;--.-&amp;#34;,&amp;#34;.-.&amp;#34;,&amp;#34;...&amp;#34;,&amp;#34;-&amp;#34;,&amp;#34;..-&amp;#34;,&amp;#34;...-&amp;#34;,&amp;#34;.--&amp;#34;,&amp;#34;-..-&amp;#34;,&amp;#34;-.--&amp;#34;,&amp;#34;--..&amp;#34;] 给你一个字符串数组 words ，每个单词可以写成每个字母对应摩尔斯密码的组合。
例如，&amp;quot;cab&amp;quot; 可以写成 &amp;quot;-.-..--...&amp;quot; ，(即 &amp;quot;-.-.&amp;quot; + &amp;quot;.-&amp;quot; + &amp;quot;-...&amp;quot; 字符串的结合)。我们将这样一个连接过程称作 单词翻译 。 对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。
思路 # 哈希 # 代码 # 哈希 # class Solution { public String charToString(Character ch) { switch (ch) { case &amp;#39;a&amp;#39; : return &amp;#34;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0817.-Linked-List-Components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0817.-Linked-List-Components/</guid>
      <description>0817. Linked List Components # 题目 # 给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值。同时给定列表 nums，该列表是上述链表中整型值的一个子集。
返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public int numComponents(ListNode head, int[] nums) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for(int x: nums) set.add(x); boolean flag = false; int num = 0; ListNode ptr = head; while (ptr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0819.-Most-Common-Word/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0819.-Most-Common-Word/</guid>
      <description>0819. Most Common Word # 题目 # 给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不再禁用列表中的单词。 题目保证至少有一个词不在禁用列表中，且答案唯一。 禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。 paragraph 只包含字母、空格和下列标点符号!?&#39;,;. 单词里只包含字母，不会出现省略号或者其他标点符号。 不存在没有连字符或者带有连字符的单词。 思路 # 哈希 # 代码 # 哈希 # class Solution { public String mostCommonWord (String paragraph, String[] banned) { Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (String ban: banned) set.add(ban); Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int maxCnt = 0; String maxWord = &amp;#34;&amp;#34;; Character[] punctuations = new Character[]{&amp;#39;!&amp;#39;, &amp;#39;?&amp;#39;, &amp;#39;\&amp;#39;&amp;#39;, &amp;#39;,&amp;#39;, &amp;#39;;&amp;#39;, &amp;#39;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0821.-Shortest-Distance-to-a-Character/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0821.-Shortest-Distance-to-a-Character/</guid>
      <description>0821. Shortest Distance to a Character # 题目 # 给定字符串 s 和一个字符 c，且 c 是 s 中出现过的字符。 返回整数数组 answer，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离他 最近 的字符 c 的距离。 两个下标 i 和 j 之间的 距离 为 abs(i - j)，其中 abs 是绝对值函数。 思路 # 双向遍历 # BFS # 代码 # 双向遍历 # class Solution { public int[] shortestToChar(String s, char c) { /** 双向扫描数组 */ int[] ans = new int[s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0824.-Goat-Latin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0824.-Goat-Latin/</guid>
      <description>0824. Goat Latin # 题目 # 给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。 请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下： 如果单词以元音开头，在单词后添加&amp;quot;ma&amp;quot; 例如，单词 &amp;quot;apple&amp;quot; 变为 &amp;quot;applema&amp;quot; 。 如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加&amp;quot;ma&amp;quot; 例如，单词 &amp;quot;goat&amp;quot; 变为 &amp;quot;oatgma&amp;quot; 。 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母a，索引从1开始。 例如，在第一个单词后添加 &amp;quot;a&amp;quot; ，在第二个单词后添加 &amp;quot;aa&amp;quot; ，以此类推。 返回将 sentence 转换为山羊拉丁文后的句子。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean isVowel(Character ch) { switch (Character.toLowerCase(ch)) { case &amp;#39;a&amp;#39;: case &amp;#39;e&amp;#39;: case &amp;#39;i&amp;#39;: case &amp;#39;o&amp;#39;: case &amp;#39;u&amp;#39;: return true; default: return false; } } public String toGoatLatin(String sentence) { String[] words = sentence.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0832.-Flipping-an-Image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0832.-Flipping-an-Image/</guid>
      <description>0832. Flipping an Image # 题目 # 给定一个 n x n 的二进制矩阵 image ，先 水平 翻转图像，然后 反转 图像并返回 结果 。
水平翻转图片就是将图片的每一行都进行翻转，即逆序。
例如，水平翻转 [1,1,0] 的结果是 [0,1,1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。
例如，反转 [0,1,1] 的结果是 [1,0,0]。
思路 # 代码 # class Solution { public void swap(int[][] image, int r1, int c1, int r2, int c2) { /** 对于数组元素来讲，这里的最终结果都是0*/ image[r1][c1] ^= image[r2][c2]; image[r2][c2] ^= image[r1][c1]; image[r1][c1] ^= image[r2][c2]; } public int[][] flipAndInvertImage(int[][] image) { int M = image.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0844.-Backspace-String-Compare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0844.-Backspace-String-Compare/</guid>
      <description>0844. Backspace String Compare # 题目 # 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true。# 代表退格字符。 对空文本输入退格字符，文本继续为空。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean backspaceCompare(String s, String t) { int ptrS = s.length() - 1, ptrT = t.length() - 1; int cntS = 0, cntT = 0; while (ptrS &amp;gt;= 0 &amp;amp;&amp;amp; ptrT &amp;gt;= 0) { while (ptrS &amp;gt;= 0) { if (s.charAt(ptrS) == &amp;#39;#&amp;#39;) { cntS++; ptrS--; } else if (cntS &amp;gt; 0) { cntS--; ptrS--; } else break; } while (ptrT &amp;gt;= 0) { if (t.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0859.-Buddy-Strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0859.-Buddy-Strings/</guid>
      <description>0859. Buddy Strings # 题目 # 给定两个字符串 s 和 goal，若可以通过交换 s 中的两个字母后得到与 goal 相同的结果，则认为 s 与 goal 是亲密字符串。 判断给定的两个字符串是否是亲密字符串。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean buddyStrings(String s, String goal) { if (s.length() != goal.length()) return false; Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; s.length; i++) { if (s.charAt(i) != goal.charAt(i)) stack.push(i); } if (stack.size() == 0) { int[] count = new int[26]; for (int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0860.-Lemonade-Change/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0860.-Lemonade-Change/</guid>
      <description> 0860. Lemonade Change # 题目 # 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，一次购买一杯。 每位顾客支付 5 美元、10美元或20美元。必须为每名顾客正确找零，即净交易额为每名顾客支付5美元。 一开始手头没有任何零钱。 给定整数数组bills，其中bills[i]是第i位顾客付的账。 如果能给每位顾客正确找零，返回true，否则返回false。 思路 # 贪心 # 代码 # 贪心 # class Solution { public boolean lemonadeChange(int[] bills) { int five = 0, ten = 0; for (int bill: bills) { if (bill == 5) five++; else if (bill == 10) { if (--five &amp;lt; 0) return false; ten++; } else { if (ten &amp;gt; 0) { ten--; if (--five &amp;lt; 0) return false; } else { five -= 3; if (five &amp;lt; 0) return false; } } } return true; } } 致谢 # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0867.-Transpose-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0867.-Transpose-Matrix/</guid>
      <description> 0867. Transpose Matrix # 题目 # 给定一个二维整数数组 matrix，返回 matrix 的 转置矩阵。
矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。
思路 # 代码 # class Solution { public int[][] transpose(int[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] ans = new int[n][m]; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { ans[i][j] = matrix[j][i]; } } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0868.-Binary-Gap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0868.-Binary-Gap/</guid>
      <description> 0868. Binay Gap # 题目 # 给定正整数 n，找到并返回 n 的二进制表示中两个相邻 1 之间的最长距离。若不存在两个相邻的 1，返回 0。
若只有 0 将两个 1 分隔开，则认为这两个 1 彼此相邻。两个 1 之间的距离是它们的二进制表示中位置的绝对差。
思路 # 代码 # class Solution { public int binaryGap(int n) { int gap = 0, flag = -1; for (int i = 31; i &amp;gt;= 0; i--) { if (((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) { if (flag &amp;gt; 0) gap = Math.max(gap, flag - i); flag = i; } } return gap; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0876.-Middle-of-the-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0876.-Middle-of-the-Linked-List/</guid>
      <description>0876. Middle of the Linked List # 题目 # 给定一个头结点为head的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
思路 # 双指针 # 代码 # 双指针 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode middleNode(ListNode head) { ListNode sentinel = new ListNode(-1, head); ListNode middle = sentinel, fast = sentinel; while (fast !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0884.-Uncommon-Words-from-Two-Sentences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0884.-Uncommon-Words-from-Two-Sentences/</guid>
      <description>0884. Uncommon Words from Two Sentences # 题目 # 句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。 如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。 给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。 思路 # 哈希 # 代码 # 哈希 # class Solution { public String[] uncommonFromSentences(String s1, String s2) { String[] s1Array = s1.split(&amp;#34; &amp;#34;), s2Array = s2.split(&amp;#34; &amp;#34;); Map&amp;lt;String, Integer&amp;gt; s1Map = new HashMap&amp;lt;&amp;gt;(), s2Map = new HashMap&amp;lt;&amp;gt;(); for (String str: s1Array) s1Map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0888.-Fair-Candy-Swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0888.-Fair-Candy-Swap/</guid>
      <description>0888. Fair Candy Swap # 题目 # 爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 aliceSizes 和 bobSizes ，aliceSizes[i] 是爱丽丝拥有的第 i 盒糖果中的糖果数量，bobSizes[j] 是鲍勃拥有的第 j 盒糖果中的糖果数量。 两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。 返回一个整数数组 answer，其中 answer[0] 是爱丽丝必须交换的糖果盒中的糖果的数目，answer[1] 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 任何一个 。题目测试用例保证存在与输入对应的答案。 思路 # 哈希 # 代码 # 哈希 # class Solution { public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) { /** 设发生交换时，Alice和Bob拿出的糖果数量分别为x和y * sumAlice - x + y = sumBob - y + x * 成为两数之和问题 */ int nAlice = 0, nBob = 0; for (int num: aliceSizes) nAlice += num; for (int num: bobSizes) nBob += num; Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int num: aliceSizes) set.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0896.-Monotonic-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0896.-Monotonic-Array/</guid>
      <description> 0896. Monotonic Array # 题目 # 如果数组是单调递减或单调递增的，那么它是单调的。 如果对于所有 i &amp;lt;= j，nums[i] &amp;lt;= nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &amp;lt;= j，nums[i]&amp;gt; = nums[j]，那么数组 nums 是单调递减的。 当给定的数组 nums 是单调数组时返回 true，否则返回 false。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean isMonotonic(int[] nums) { int monotonicity = 0; for (int i = 0; i &amp;lt; nums.length - 1; i++) { if (nums[i] == nums[i + 1]) continue; else if (monotonicity == 0) monotonicity = num[i] - nums[i + 1]; else if ((nums[i] - nums[i + 1]) * monotonicity &amp;lt; 0) return false; } return true; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0905.-Sort-Array-by-Parity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0905.-Sort-Array-by-Parity/</guid>
      <description> 0905. Sort Array by Parity # 题目 # 给定整数数组 nums，将 nums 中偶数元素移动到数组前面，奇数元素移动到数组末端。 返回满足此条件的 任一数组 作为答案。 思路 # 双指针 # 代码 # 双指针 # class Solution { boolean isEven(int num) { return num % 2 == 0; } boolean isOdd(int num) { return num % 2 == 1; } public int[] sortArrayByParity(int[] nums) { int i = 0, j = nums.length - 1; while (i &amp;lt; j) { if (isEven(nums[i])) i += 1; else if (isOdd(nums[j])) j -= 1; else if (isEven(nums[i]) == isOdd(nums[j])) { nums[i] ^= nums[j]; nums[j] ^= nums[i]; nums[i] ^= nums[j]; i += 1; j -= 1; } } return nums; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0917.-Reverse-Only-Letters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0917.-Reverse-Only-Letters/</guid>
      <description>0917. Reverse Only Letters # 题目 # 给定字符串 s ，根据下述规则反转字符串： 所有非英文字母保留在原有位置。 所有英文字母（小写或大写）位置反转。 返回反转后的 s 。 思路 # 双指针 # 代码 # 双指针 # class Solution { public String reverseOnlyLetters(String s) { char[] charArray = s.toCharArray(); int i = 0, j = s.length() - 1; while (i &amp;lt; j) { if (Character.isLetter(s.charAt(i)) == false) i++; else if (Character.isLetter(s.charAt(j)) == false) j--; else { char ch = charArray[i]; charArray[i] = charArray[j]; charArray[j] = charArray[i]; i++; j--; } } return String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0929.-Unique-Email-Addresses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0929.-Unique-Email-Addresses/</guid>
      <description>0929. Unique Email Addresses # 题目 # 每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 &#39;@&#39; 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 &#39;.&#39; 或 &#39;+&#39; 。 例如，在 alice@leetcode.com中， alice 是 本地名 ，而 leetcode.com 是 域名 。 如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（&#39;.&#39;），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。 例如，&amp;quot;alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 如果在 本地名 中添加加号（&#39;+&#39;），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。 例如 m.y+name@email.com 将转发到 my@email.com。 可以同时使用这两个规则。 给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int numUniqueEmails(String[] emails) { Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (String email: emails) { char[] charArray = email.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0933.-Number-of-Recent-Calls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0933.-Number-of-Recent-Calls/</guid>
      <description>933. Number of Recent Calls # 题目 # 写一个 RecentCounter 类来计算特定时间范围内最近的请求。
请你实现 RecentCounter 类：
RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 每次对 ping 的调用都使用比之前更大的 t 值。 思路 # 队列 # 代码 # 队列 # class RecentCounter { private Queue&amp;lt;Integer&amp;gt; queue; public RecentCounter() { this.queue = new LinkedList&amp;lt;&amp;gt;(); } public int ping(int t) { queue.offer(t); while (queue.peek() &amp;lt; t - 3000) queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0953.-Verifying-an-Alien-Dictionary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0953.-Verifying-an-Alien-Dictionary/</guid>
      <description>0953. Verifying an Alien Dictionary # 题目 # 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。 给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。 思路 # 模拟 # 自定义排序 # 代码 # 模拟 # class Solution { public boolean compareWords(String word1, String word2, Map&amp;lt;Character, Integer&amp;gt; map) { int ptr1 = 0, ptr2 = 0; while (ptr1 &amp;lt; word1.length() &amp;amp;&amp;amp; ptr2 &amp;lt; word2.length()) { int order1 = map.get(word1.charAt(ptr1)), order2 = map.get(word2.charAt(ptr2)); if (order1 &amp;gt; order2) return false; if (order1 &amp;lt; order2) return true; ptr1++; ptr2++; } return ptr1 == word1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0965.-Univalued-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0965.-Univalued-Binary-Tree/</guid>
      <description>965. Univalued Binary Tree # 题目 # 如果二叉树的每个节点都具有相同的值，那么该二叉树就是 单值 二叉树。
只有给定的树是单值二叉树时，才返回 true，否则返回 false。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean preOrderTraversal(TreeNode root, int uniVal) { if (root == null) return true; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0977.-Squares-of-A-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0977.-Squares-of-A-Sorted-Array/</guid>
      <description>0977. Squares of A Sorted Array # 题目 # 给定按 非递减顺序 排序的整型数组 nums，返回 每个数字的平方 组成的新数组，要求新数组也按 非递减顺序 排序。
思路 # 双指针 # 代码 # 双指针 # class Solution { public int[] sortedSquares(int[] nums) { int[] ans = new int[nums.length]; int i = 0, j = nums.length - 1, ptr = nums.length - 1; while (i &amp;lt;= j) { int num = Math.abs(nums[i]) &amp;gt; Math.abs(nums[j]) ? nums[i++] : nums[j--]; ans[ptr--] = num * num; } return ans; } } class Solution { public int[] sortedSquares(int[] nums) { if (nums == null) return null; int sz = nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0997.-Find-the-Town-Judge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0900-to-0999/0997.-Find-the-Town-Judge/</guid>
      <description> 0997. Find the Town Judge # 题目 # 小镇中有n个人，按从1到n的顺序编号。传言称，这些人中有一个暗地里是小镇法官。 如果小镇法官真的存在，那么： 小镇法官不会信任任何人。 每个人（除了小镇法官）都信任这位小镇法官。 只有一个人同时满足前两条。 给定数组trust，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。 如果小镇法官存在，请返回该法官的编号。否则返回-1。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int findJudge(int n, int[][] trust) { int[] cntMyTrust = new int[n + 1], cntTrustMe = new int[n + 1]; for (int[] pair: trust) { cntMyTrust[pair[0]]++; cntTrustMe[pair[1]]++; } for (int i = 1; i &amp;lt;= n; i++) { if (cntMyTrust[i] == 0 &amp;amp;&amp;amp; cntTrustMe[i] == n - 1) return i; } return -1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1019.-Next-Greater-Node-in-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1019.-Next-Greater-Node-in-Linked-List/</guid>
      <description>1019. Next Grater Node in Linked List # 题目 # 给定一个长度为n的链表head
对于链表中的每个节点，查找下一个更大节点的值。即，对于每个节点，找到它旁边的第一个节点的值，这个节点的值严格大于它的值。
返回一个整数数组answer，其中answer[i]是第i个节点（从1开始）的下一个更大节点的值。如果第i个节点没有下一个更大的节点，设置answer[i] = 0。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public int[] nextLargerNodes(ListNode head) { /** 1. 统计链表长度 */ int length = 0; ListNode ptr = head; while (ptr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1021.-Remove-Outermost-Parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1021.-Remove-Outermost-Parentheses/</guid>
      <description>1021. Remove Outermost Parentheses # 题目 # 有效括号字符串为空 &amp;quot;&amp;quot;、&amp;quot;(&amp;quot; + A + &amp;quot;)&amp;quot; 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。 例如，&amp;quot;&amp;quot;，&amp;quot;()&amp;quot;，&amp;quot;(())()&amp;quot; 和 &amp;quot;(()(()))&amp;quot; 都是有效的括号字符串。 如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。 对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String removeOuterParentheses(String s) { String ans = &amp;#34;&amp;#34;; int left = 0, right = 0; for (int i = 0, j = 0; j &amp;lt; s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1037.-Valid-Boomerang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1037.-Valid-Boomerang/</guid>
      <description>1037. Valid Boomerang # 题目 # 给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。 回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。 思路 # 斜率 # 向量叉积 # 代码 # 斜率 # class Solution { public boolean isSame(int[] p, int[] q) { return p[0] == q[0] &amp;amp;&amp;amp; p[1] == q[1]; } public boolean isColinear(int[] p, int[] q, int[] r) { if (p[0] == q[0]) return p[0] == r[0]; return ((double)q[1] - p[1])) / (q[0] - p[0]) == ((double)r[1] - p[1]) / (r[0] - p[0]); } public boolean isBoomerang(int[][] points) { int[] p0 = points[0], p1 = points[1], p2 = points[2]; if (isSame(p0, p1) || isSame(p0, p2) || isSame(p1, p2)) return false; return isColinear(p0, p1, p2) == false; } } 向量叉积 # 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1047.-Remove-All-Adjacent-Duplicates-In-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1047.-Remove-All-Adjacent-Duplicates-In-String/</guid>
      <description>1047. Remove All Adjacent Duplicates In String # 题目 # 给出由小写字母组成的字符串 S， 重复项删除操作会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直至无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。
思路 # 代码 # class Solution { public String removeDuplicates(String s) { Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;s.length(); i++) { char item = s.charAt(i); if (stack.empty() == false &amp;amp;&amp;amp; stack.peek() == item) stack.pop(); else stack.push(item); } char[] unique = new char[stack.size()]; for (int i=unique.length-1; i&amp;gt;=0; i--) unique[i] = stack.pop(); return String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1078.-Occurrences-After-Bigram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1078.-Occurrences-After-Bigram/</guid>
      <description>1078. Occurrences After Bigram # 题目 # 给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 &amp;quot;first second third&amp;quot; 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 &amp;ldquo;third&amp;rdquo; 添加到答案中，并返回答案。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String[] findOcurrences(String text, String first, String second) { List&amp;lt;String&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); String[] words = text.split(&amp;#34; &amp;#34;); for (int i = 0; i &amp;lt; words.length - 2; i++) { if (words[i].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1089.-Duplicate-Zeros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1000-to-1099/1089.-Duplicate-Zeros/</guid>
      <description>1089. Duplicate Zeros # 题目 # 给定长度固定的整数数组 arr，将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 注：不要在超过该数组长度的位置写入元素。对输入数组 原地 修改，不要从函数返回任何值。 思路 # 双指针 # 代码 # 双指针 # class Solution { public void duplicateZeros(int[] arr) { /** 1. 由于复写零的存在，只需要不超过arr.length个原始数组元素即可将arr填满，首先确定需要多少个元素将arr填满 */ int sum = 0, ptr = -1; while (sum &amp;lt; arr.length) { ptr++; if (arr[ptr] == 0) sum += 2; else dum += 1; } /** 2. sum的最终取值存在arr.length和arr.length+1两种情况 */ /** 3. 从后向前填充数组 */ for (int i = arr.length - 1; ptr &amp;gt; -1; ) { if (arr[ptr] == 0 &amp;amp;&amp;amp; sum &amp;lt;= arr.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1108.-Defanging-an-IP-Address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1108.-Defanging-an-IP-Address/</guid>
      <description>1108. Defanging an IP Address # 题目 # 给定一个有效的IPV4地址address，返回这个IP地址的无效化版本。
无效化IP地址，就是用&amp;quot;[.]&amp;quot;代替了每个&amp;quot;.&amp;quot;。
思路 # 模拟 # 代码 # 模拟 # class Solution { public String defangIPaddr(String address) { char[] and = new char[address.length() + 6]; int ptrAns = 0, ptrAddress = 0; while (ptrAns &amp;lt; ans.length) { if (address.charAt(ptrAddress) != &amp;#39;.&amp;#39;) { ans[ptrAns++] = address.charAt(ptrAddress); } else { ans[ptrAns++] = &amp;#39;[&amp;#39;; ans[ptrAns++] = &amp;#39;.&amp;#39;; ans[ptrAns+=] = &amp;#39;]&amp;#39;; } ptrAddress++; } return String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1137.-N-th-Tribonacci-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1137.-N-th-Tribonacci-Number/</guid>
      <description>1137. N-th Tribonacci Number # 题目 # 泰波那契序列 Tn 定义如下：
T0 = 0, T1 = 1, T2 = 1, 且在 n &amp;gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
模拟 # 代码 # 模拟 # class Solution { public int tribonacci(int n) { if (n == 0) return 0; if (n == 1) return 1; if (n == 2) return 1; int[] mem = new int[n+1]; mem[0] = 0; mem[1] = mem[2] = 1; for (int i = 3; i &amp;lt;= n; i++) mem[i] = mem[i-1]+mem[i-2]+mem[i-3]; return mem[n]; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1154.-Day-of-the-Year/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1154.-Day-of-the-Year/</guid>
      <description>1154. Day of the Year # 题目 # 给定字符串 date，按YYYY-MM-DD格式表示一个现行公元年法日期。
返回该日期是当年的第几天。
思路 # 模拟 # 打表 # 代码 # 模拟 # class Solution { public boolean isLeapYear(int year) { /** 能被4整除但不能被100整除的是闰年 * 能被400整除的是闰年 */ return (year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0) || year % 400 == 0; } public int dayOfYear(String date) { int year = Integer.parseInt(date.split(&amp;#34;-&amp;#34;)[0]); int month = Integer.parseInt(date.split(&amp;#34;-&amp;#34;)[1]); int day = Integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1171.-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1171.-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</guid>
      <description>1171. Remove Zero Sum Consecutive Nodes from Linked List # 题目 # 给定链表头节点 head ，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。
删除完毕后，返回最终结果链表的头节点。
思路 # 考察第 k 个链表结点，判断其是否位于某个 零子序列 中，只需通过检查第 k-1 个结点的前缀和在 &amp;gt;=k 结点处是否再次出现。 可以通过两次遍历链表，借助 HashMap 实现这一需求 第一趟遍历，计算每个结点的前缀和，并构建前缀和与最远结点的映射关系 第二趟遍历，从哨兵结点开始，从映射中查找当前前缀和对应的结点，若找到则移除之间的结点。 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeZeroSumSublists(ListNode head) { ListNode sentinel = new ListNode(0, head); Map&amp;lt;Integer, ListNode&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1184.-Distance-Between-Bus-Stops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1184.-Distance-Between-Bus-Stops/</guid>
      <description>1184. Distance Between Bus Stops # 题目 # 环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。
环线上的公交车都可以按顺时针和逆时针的方向行驶。
返回乘客从出发点 start 到目的地 destination 之间的最短距离。
思路 # 模拟 # 代码 # 模拟 # class Solution { public int distanceBetweenBusStops(int[] distance, int start, int destination) { int res1 = 0, totalDist = 0; for (int i = Math.min(start, destination); i &amp;lt; Math.max(start, destination); i++) res1 += distance[i]; for (int dist: distance) totalDist += dist; return Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1185.-Day-of-the-Week/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1185.-Day-of-the-Week/</guid>
      <description>1185. Day of the Week # 题目 # 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
输入为三个整数：day、month 和 year，分别表示日、月、年。
您返回的结果必须是这几个值中的一个 {&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;}。
思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean isLeapYear(int year) { return (year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0) || year % 400 == 0; } public int[] dayOfMonths (int year) { int[] days = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; if (isLeapYear(year)) days[1]++; return days; } public String dayOfTheWeek(int day, int month, int year) { /** 1971/01/01 is Friday.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1189.-Maximum-Number-of-Balloons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1189.-Maximum-Number-of-Balloons/</guid>
      <description>1189. Maximum Number of Balloons # 题目 # 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 &amp;ldquo;balloon&amp;rdquo;（气球）。
字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 &amp;ldquo;balloon&amp;rdquo;。
思路 # 模拟 # 代码 # 模拟 # class Solution { public int maxNumberOfBalloons(String text) { /** balon */ int[] count = new int[5]; for (int i = 0; i &amp;lt; text.length(); i++) { switch (text.charAt(i)) { case &amp;#39;b&amp;#39; : count[0]++; break; case &amp;#39;a&amp;#39; : count[1]++; break; case &amp;#39;l&amp;#39; : count[2]++; break; case &amp;#39;o&amp;#39; : count[3]++; break; case &amp;#39;n&amp;#39; : count[4]++; break; } } int ans = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1206.-Design-SkipList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1206.-Design-SkipList/</guid>
      <description>1206. Design SkipList # 题目 # 不使用任何库函数，设计一个 跳表 。
跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于AVL树和红黑树，性能与之相当。且跳表的代码长度相较下更短，其设计思想与链表相似。
跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。，
本题的设计应该包含以下函数：
bool search(int target)：返回 target 是否存在于跳表中。 void add(int num)：插入一个元素到跳表。 bool erase(int num)：在跳表中删除一个值，如果 num 不存在，直接返回 false。如果存在多个 num，删除其中任意一个即可。 Tips 跳表中可能存在多个相同的值，所设计的跳表需要处理这种情况。
思路 # 代码 # class Skiplist { private int MAX_LEVEL = 10; private class SkipNode { public int val; public SkipNode[] next; SkipNode(int val) { this.val = val; this.next = new SkipNode[this.MAX_LEVEL]; } } private SkipNode sentinel; private Random random; public Skiplist() { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1265.-Print-Immutable-Linked-List-in-Reverse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1265.-Print-Immutable-Linked-List-in-Reverse/</guid>
      <description> 1265. Print Immutable Linked List in Reverse # 题目 # 给定一个不可变的链表，使用下列接口逆序打印每个节点的值：
ImmutableListNode: 描述不可变链表的接口，链表的头节点已给出。 使用以下 API 来访问此链表：
ImmutableListNode.printValue()：打印当前节点的值。 ImmutableListNode.getNext()：返回下一个节点。 思路 # 代码 # class Solution { public void printLinkedListInReverse(ImmutableListNode head) { if (head == null) return; printLinkedListInReverse(head.getNext()); head.printValue(); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1290.-Convert-Binary-Number-in-A-Linked-List-to-Integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1290.-Convert-Binary-Number-in-A-Linked-List-to-Integer/</guid>
      <description>1290. Convert Binary Number in A Linked List to Integer # 题目 # 给定单链表头节点head，已知此链表是一个整数数字的二进制表示形式，链表中每个节点的值非0即1。返回链表所表示数字的十进制值。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null, cur = head, next = head.next; while(cur != null) { cur.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1295.-Find-Numbers-with-Even-Number-of-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1200-to-1299/1295.-Find-Numbers-with-Even-Number-of-Digits/</guid>
      <description>1295. Find Numbers with Even Number of Digits # 题目 # 给定整数数组 nums，返回其中位数为 偶数 的数字的个数。 思路 # 模拟 # 数学 # 代码 # 模拟 # class Solution { public int count(int num) { int ans = 0; while (num &amp;gt; 0) { ans++; num /= 10; } return ans; } public int findNumbers(int[] nums) { int ans = 0; for (int num: nums) ans += ocunt(num) % 2 == 0 ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1331.-Rank-Transform-of-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1331.-Rank-Transform-of-an-Array/</guid>
      <description>1331. Rank Transform of an Array # 题目 # 给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。 一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。 每个数字的序号都应该尽可能地小。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int[] arrayRankTransform(int[] arr) { Map&amp;lt;Integer, Queue&amp;lt;Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; arr.length; i++) { if (map.containsKey(arr[i]) == false) map.put(arr[i], new LinkedList&amp;lt;&amp;gt;()); map.get(arr[i]).offer(i); } Arrays.sort(arr); int[] ans = new int[arr.length]; Map&amp;lt;Integer, Integer&amp;gt; record = new HashMap&amp;lt;&amp;gt;(); int rank = 0; for (int i = 0; i &amp;lt; ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1342.-Number-of-Steps-to-Reduce-a-Number-to-Zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1342.-Number-of-Steps-to-Reduce-a-Number-to-Zero/</guid>
      <description>1342. Number of Steps to Reduce a Number to Zero # 题目 # 给你一个非负整数 nums，返回将它变为 0 所需要的步数。
如果当前数字是偶数，则将它除以 2，否则减去 1。
思路 # 模拟 数学 + 位运算 可从如下角度考虑模拟过程: 若 nums 最低位非 1，则进行右移 若 nums 最低位为 1，则消减最低位的 1 总操作次数等于: 最高位 1 的右移次数 + nums 的二进制表示中 1 的个数 代码 # 模拟 # class Solution { public int numberOfSteps(int num) { int step = 0; while (num != 0 &amp;amp;&amp;amp; ++step &amp;gt; 0) num = (num &amp;amp; 1 == 0) ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1374.-Generate-a-String-With-Characters-That-Have-Odd-Counts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1374.-Generate-a-String-With-Characters-That-Have-Odd-Counts/</guid>
      <description>1374. Generate a String With Characters That Have Odd Counts # 题目 # 给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String generateTheString(int n) { String ans = &amp;#34;&amp;#34;; if (n % 2 == 0) { for (int i = 0; i &amp;lt; n - 1; i++) ans += &amp;#34;a&amp;#34;; ans += &amp;#34;b&amp;#34;; } else { for (int i = 0; i &amp;lt; n; i++) ans += &amp;#34;a&amp;#34;; } return ans; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1380.-Lucky-Numbers-in-a-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1380.-Lucky-Numbers-in-a-Matrix/</guid>
      <description>1380. Lucky Numbers in a Matrix # 题目 # 给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 幸运数 是指矩阵中满足同时下列两个条件的元素： 在同一行的所有元素中最小 在同一列的所有元素中最大 思路 # 模拟 # 代码 # 模拟 # class Solution { public List&amp;lt;Integer&amp;gt; luckyNumbers (int[][] matrix) { List&amp;lt;Integer&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); int M = matrix.length, N = matrix[0].length; int[] minimumRow = new int[M], maximumCol = new int[N]; Arrays.fill(minimumRow, Integer.MAX_VALUE); Arrays.fill(maximumCol, Integer.MIN_VALUE); for (int i = 0; i &amp;lt; M; i++) { for (int j = 0; j &amp;lt; N; j++) { minimumRow[i] = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1394.-Find-Lucky-Integer-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1300-to-1399/1394.-Find-Lucky-Integer-in-an-Array/</guid>
      <description> 1394. Find Lucky Integer in an Array # 题目 # 在整数数组中，如果一个整数的出现频次和它的数值大小相等，则称此整数为 幸运数。
给定整数数组 arr，从中找出并返回一个幸运数。
若数组中存在多个幸运数，则返回最大的那个。若数组中不含幸运数，返回 -1。
思路 # 代码 # class Solution { public int findLucky(int[] arr) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int num: arr) map.put(num, map.getOrDefault(num, 0) + 1); int maxLucky = -1; for (Integer x: map.keySet()) if (map.get(x) == x) maxLucky = Math.max(x, maxLucky); return maxLucky; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1408.-String-Matching-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1408.-String-Matching-in-an-Array/</guid>
      <description>1408. String Matching in an Array # 题目 # 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 words[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。
思路 # 模拟 # 代码 # 模拟 # class Solution { public List&amp;lt;String&amp;gt; stringMatching(String[] words) { Set&amp;lt;String&amp;gt; ans = new HashSet(); for (int i = 0; i &amp;lt; words.length; i++) { for (int j = 0; j &amp;lt; words.length; j++) { if (j == i) continue; if (words[j].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1413.-Minimum-Value-to-Get-Positive-Step-by-Step-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1413.-Minimum-Value-to-Get-Positive-Step-by-Step-Sum/</guid>
      <description>1413. Minimum Value to Get Positive Step by Step Sum # 题目 # 给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。
你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。
请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。
思路 # 模拟 # 代码 # 模拟 # class Solution { public int minStartValue(int[] nums) { int ans = 1, prefixSum = 1; for (int num: nums) { prefixSum += num; if (prefixSum &amp;lt; 1) { ans += 1 - prefixSum; prefixSum = 1; } } return ans; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1417.-Reformat-The-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1417.-Reformat-The-String/</guid>
      <description>1417. Reformat The String # 题目 # 给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。
请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。
请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。
思路 # 模拟 # 代码 # 模拟 # class Solution { public String reformat(String s) { LinkedList&amp;lt;Character&amp;gt; charList = new LinkedList&amp;lt;&amp;gt;(), digitList = new LinkedList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; s.length(); i++) { char ch = s.charAt(i); if (Character.isDigit(ch)) digitList.add(ch); else charList.add(ch); } if (Math.abs(charList.size() - digitList.size()) &amp;gt; 1) return &amp;#34;&amp;#34;; List&amp;lt;Character&amp;gt; Long = charList.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1422.-Maximum-Score-After-Splitting-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1422.-Maximum-Score-After-Splitting-a-String/</guid>
      <description>1422. Maximum Score After Splitting a String # 题目 # 给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。
「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。
思路 # 模拟 # 代码 # 模拟 # class Solution { public int maxScore(String s) { int N = s.length(); /** 令zeros[i]记录截止下标i处字符串中共出现了多少个0 */ int[] zeros = new int[N], ones = new int[N]; for (int i = 0; i &amp;lt; N; i++) { switch (s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1436.-Destination-City/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1436.-Destination-City/</guid>
      <description>1436. Destination City # 题目 # 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市*。*
题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
思路 # 模拟+哈希 # 代码 # 模拟+哈希 # class Solution { public String destCity (List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { Set&amp;lt;String&amp;gt; start = new HashSet&amp;lt;&amp;gt;(); Set&amp;lt;String&amp;gt; end = new HashSet&amp;lt;&amp;gt;(); for (List&amp;lt;String&amp;gt; path: paths) { /** consider start */ start.add(path.get(0)); if (end.contains(path.get(0))) end.remove(path.get(0)); /** consider end */ if (start.contains(path.get(1)) == false) end.add(path.get(1)); else if (end.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1446.-Consecutive-Characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1446.-Consecutive-Characters/</guid>
      <description> 1446. Consecutive Characters # 题目 # 字符串的**「能量」**定义为：只包含一种字符的最长非空子字符串的长度。
返回字符串 s 的 能量。
思路 # 模拟 # 代码 # 模拟 # class Solution { public int maxPower(String s) { int maxPower = 1, power = 1; char ch = s.charAt(0); for (int i = 1; i &amp;lt; s.length(); i++) { if (s.charAt(i) == ch) { power += 1; maxPower = Math.max(power, maxPower); } else { power += 1; ch = s.charAt(i); } } return maxPower; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1455.-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1455.-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/</guid>
      <description>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence # 题目 # 给定字符串 sentence 并指定检索词为 searchWord ，句子由 空格 分隔的单词组成。 检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。 如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。 如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 s 的 前缀 是 s 的任何前导连续子字符串。 思路 # 双指针 # 代码 # 双指针 # class Solution { public int isPrefixOfWord(String sentence, String searchWord) { int ptr1 = 0, ans = 0; while (ptr1 &amp;lt; sentence.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1460.-Make-Two-Arrays-Equal-by-Reversing-Subarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1460.-Make-Two-Arrays-Equal-by-Reversing-Subarrays/</guid>
      <description>1460. Make Two Arrays Equal by Reversing Subarrays # 题目 # 给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。 如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean canBeEqual(int[] target, int[] arr) { int[] record = new int[1001]; for (int num: arr) record[num]++; for (int num: target) record[num]--; for (int num: record) if (num &amp;gt; 0) return false; return true; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1464.-Maximum-Product-of-Two-Elements-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1464.-Maximum-Product-of-Two-Elements-in-an-Array/</guid>
      <description>1464. Maximum Product of Two Elements in an Array # 题目 # 给定一个整数数组nums，选择数组的两个不同下表i和j，使(nums[i]-1)*(nums[j]-1)取得最大值。 计算并返回该式的最大值。 2 &amp;lt;= nums.length &amp;lt;= 500 1 &amp;lt;= nums[i] &amp;lt;= 10^3 思路 # 模拟 # 代码 # 模拟 # class Solution { public int maxProduct(int[] nums) { int[] ans = new int[2]; for (int num: nums) { if (ans[0] == 0) ans[0] = num; else { if (num &amp;gt;= ans[0]) { ans[1] = ans[0]; ans[0] = num; } else if (num &amp;gt;= ans[1]) ans[1] = num; } } return (ans[0] - 1) * (ans[1] - 1); } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1470.-Shuffle-the-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1470.-Shuffle-the-Array/</guid>
      <description> 1470. Shuffle the Array # 题目 # 给定数组 nums，数组中有 2n 个元素，按[x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int[] shuffle(int[] nums, int n) { int[] ans = new int[nums.length]; for (int i = 0; i &amp;lt; n; i++) { ans[2*i] = nums[i]; ans[2*i+1] = nums[i+n]; } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1472.-Design-Browser-History/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1472.-Design-Browser-History/</guid>
      <description>1472. Design Browser History # 题目 # 现有一个只支持单个标签页的 浏览器， 最开始浏览的网页是 homepage，可以访问其他的网站 url，也可以在浏览器中后退 steps 步或前进 steps 步。
设计实现 BrowserHistory 类：
BrowserHistory(string homepage) 用 homepage 初始化浏览器类。 void visit(string url) 从当前页面跳转访问 url 对应的页面。执行此操作会把浏览历史前进的记录全部删除。 string back(int steps) 在浏览历史中后退 steps 步。如果只能在浏览历史中后退至多 x 步且 steps &amp;gt; x，那么只后退 x 步。请返回后退至多 steps 步以后的 url。 string forward(int steps) 在浏览历史中前进 steps 步。如果只能在浏览历史中前进至多 x 步且 steps &amp;gt; x，那么只前进 x 步。请返回前进至多 steps 步以后的 url。 思路 # 借助双向链表实现。 注意 visit 操作执行后会将浏览历史前进的记录全部删除。 代码 # class BrowserHistory { private class ListNode { public String url; public ListNode prev; public ListNode next; ListNode(String url, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1474.-Delete-N-Nodes-After-M-Nodes-of-A-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1474.-Delete-N-Nodes-After-M-Nodes-of-A-Linked-List/</guid>
      <description>1472. Design Browser History # 题目 # 给定链表头结点 head 和两个整数 m 和 n，遍历该链表并按照如下方式删除结点：
开始时以头结点作为当前结点 保留以当前结点开始的前 m 个结点 删除接下来的 n 个结点 重复步骤 2 和 3，直到到达链表结尾 在删除了指定结点之后，返回修改过后的链表头结点。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } LIstNOde(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteNodes(ListNode head, int m, int n) { ListNode sentinel = new ListNode(-1, head); ListNode ptr = sentinel; while (ptr.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1480.-Running-Sum-of-1d-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1480.-Running-Sum-of-1d-Array/</guid>
      <description> 1480. Running Sum of 1d Array # 题目 # 数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
给定数组 nums 。返回 nums 的动态和。
思路 # 模拟 # 代码 # 模拟 # class Solution { public int[] runningSum(int[] nums) { for (int i = 1; i &amp;lt; nums.length; i++) nums[i] += nums[i-1]; return nums; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1486.-XOR-Operation-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1486.-XOR-Operation-in-an-Array/</guid>
      <description> 1486. XOR Operation in an Array # 题目 # 给定两个整数，n 和 start。
数组 nums 定义为: nums[i] = start + 2*i （下标从0开始）且 n == nums.length。
返回 nums 中所有元素按位异或 (XOR) 后得到的结果。
思路 # 代码 # class Solution { public int xorOperation(int n, int start) { int xor = 0; for (int i = 0; i &amp;lt; n; i++) xor ^= start + 2 * i; return xor; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1491.-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1400-to-1499/1491.-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/</guid>
      <description>1491. Average Salary Excluding the Minimum and Maximum Salary # 题目 # 给定整数数组 salary，数组中每个数都是唯一的，其中 salary[i] 是第 i 个员工的工资。 返回去掉最低工资和最高工资后，剩下员工工资的平均值。 思路 # 模拟 # 代码 # 模拟 # class Solution { public double average(int[] salary) { int minSalary = Integer.MAX_VALUE, maxSalary = Integer.MIN_VALUE, sum = 0; for (int num: salary) { minSalary = Math.min(minSalary, num); maxSalary = Math.max(maxSalary, num); sum += num; } return (double)(sum - minSalary - maxSalary) / (salary.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1518.-Water-Bottles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1518.-Water-Bottles/</guid>
      <description>1518. Water Bottles # 题目 # 超市正在促销，你可以用 numExchange 个空水瓶从超市兑换一瓶水。最开始，你一共购入了 numBottles 瓶水。 如果喝掉了水瓶中的水，那么水瓶就会变成空的。 给你两个整数 numBottles 和 numExchange ，返回你 最多 可以喝到多少瓶水。 思路 # 模拟 # 数学 # 代码 # 模拟 # class Solution { public int numWaterBottles(int numBottles, int numExchange) { int drink = numBottles, empty = numBottles; while (empty / numExchange != 0) { drink += empty / numExchange; empty = empty / numExchange + empty % numExchange; } return drink; } } 数学 # 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1576.-Replace-All-s-to-Avoid-Consecutive-Repeating-Characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1576.-Replace-All-s-to-Avoid-Consecutive-Repeating-Characters/</guid>
      <description>1576. Replace All ?&amp;rsquo;s to Avoid Consecutive Repeating Characters # 题目 # 给定一个仅包含小写英文字母和 &#39;?&#39; 字符的字符串 s，将所有的 &#39;?&#39; 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 不能 修改非 &#39;?&#39; 字符。 除 &#39;?&#39; 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。 思路 # 模拟 # 代码 # 模拟 # class Solution { private Random random = new Random(); public Character findCandidate(Character ban1, Character ban2) { Character ans = &amp;#39;a&amp;#39;; while (ans == ban1 || ans == ban2) { ans = (char)(&amp;#39;a&amp;#39; + this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1582.-Special-Positions-in-a-Binary-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1582.-Special-Positions-in-a-Binary-Matrix/</guid>
      <description>1582. Special Positions in a Binary Matrix # 题目 # 给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。 特殊位置 定义：如果 mat[i][j] == 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int numSpecial(int[][] mat) { Map&amp;lt;Integer, Integer&amp;gt; cntRows = new HashMap&amp;lt;&amp;gt;(); Map&amp;lt;Integer, Integer&amp;gt; cntCols = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; mat.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1592.-Rearrange-Spaces-Between-Words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1592.-Rearrange-Spaces-Between-Words/</guid>
      <description>1592. Rearrange Spaces Between Words # 题目 # 给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。 请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。 返回 重新排列空格后的字符串 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String reorderSpaces(String text) { int numLetters = 0; List&amp;lt;String&amp;gt; words = new LinkedList&amp;lt;&amp;gt;(); String word = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; text.length(); i++) { if (Character.isLetter(text.charAt(i))) word += text.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1598.-Crawler-Log-Folder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1500-to-1599/1598.-Crawler-Log-Folder/</guid>
      <description>1598. Crawler Log Folder # 题目 # 每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。下面给出对变更操作的说明： &amp;quot;../&amp;quot; ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。 &amp;quot;./&amp;quot; ：继续停留在当前文件夹**。** &amp;quot;x/&amp;quot; ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。 给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。 文件系统启动时位于主文件夹，然后执行 logs 中的操作。 执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int minOperations(String[] logs) { int ans = 0; for (String log: logs) { switch (log) { case &amp;#34;../&amp;#34;: if (ans &amp;gt; 0) ans -= 1; break; case &amp;#34;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1608.-Special-Array-With-X-Elements-Greater-Than-or-Equal-X/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1608.-Special-Array-With-X-Elements-Greater-Than-or-Equal-X/</guid>
      <description>1608. Special Array With X Elements Greater Than or Equal X # 题目 # 给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。
注意： x 不必 是 nums 的中的元素。
如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
思路 # 排序 # 代码 # 排序 # class Solution { public int specialArray(int[] nums) { Arrays.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1614.-Maximum-Nesting-Depth-of-the-Parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1614.-Maximum-Nesting-Depth-of-the-Parentheses/</guid>
      <description>1614. Maximum Nesting Depth of the Parentheses # 题目 # 有效括号字符串满足下列条件之一
字符串是一个空字符串 &amp;quot;&amp;quot;，或者是一个不为 &amp;quot;(&amp;quot; 或 &amp;quot;)&amp;quot; 的单字符。
字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
有效括号字符串 S 的 嵌套深度 depth(S) 定义为：
depth(&amp;quot;&amp;quot;) = 0
depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 &amp;quot;(&amp;quot; 或者 &amp;quot;)&amp;quot;
depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
depth(&amp;quot;(&amp;quot; + A + &amp;quot;)&amp;quot;) = 1 + depth(A)，其中 A 是一个 有效括号字符串</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1624.-Largest-Substring-Between-Two-Equal-Characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1624.-Largest-Substring-Between-Two-Equal-Characters/</guid>
      <description>1624. Largest Substring Between Two Equal Characters # 题目 # 给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 *，*计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。
子字符串 是字符串中的一个连续字符序列。
思路 # 模拟 # 代码 # 模拟 # class Solution { public int maxLengthBetweenEqualCharacters(String s) { int[] pos = new int[26]; Arrays.fill(pos, -1); int ans = -1; for (int i = 0; i &amp;lt; s.length(); i++) { Character ch = s.charAt(i); if (pos[ch-&amp;#39;a&amp;#39;] == -1) pos[ch-&amp;#39;a&amp;#39;] = i; else ans = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1629.-Slowest-Key/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1629.-Slowest-Key/</guid>
      <description>1629. Slowest Key # 题目 # LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。
给定长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。
测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。
注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。
返回单次按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。
思路 # 模拟 # 代码 # 模拟 # class Solution { public char slowestKey(int[] releaseTimes, String keyPressed) { char ans = keyPressed.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1634.-Add-Two-Polynomials-Represented-as-Linked-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1634.-Add-Two-Polynomials-Represented-as-Linked-Lists/</guid>
      <description>1634. Add Two Polynomials Represented as Linked Lists # 题目 # 多项式链表是一种特殊形式的链表，每个结点表示多项式的一项。
每个结点有三个属性：
coefficient： 该项的系数 power：该项的指数 next：指向下一个结点的指针，如果当前结点为链表的最后一个结点则为 null 多项式链表是标准形式的，即多项式 严格 按指数 power 的递减顺序排列。系数 coefficient 为 0 的项需要省略。
给定两个多项式链表的头结点 poly1 和 poly2，返回它们的和的头结点。
思路 # 代码 # class PolyNode { int coefficient, power; PolyNode next = null; PolyNode() {} PolyNode(int x, int y) { this.coefficient = x; this.power = y; } PolyNode(int x, int y, PolyNode next) { this.coefficient = x; this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1646.-Get-Maximum-in-Generated-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1646.-Get-Maximum-in-Generated-Array/</guid>
      <description>1646. Get Maximum in Generated Array # 题目 # 给定一个整数n，按下述规则生成一个长度为n+1的数组nums： nums[0] = 0 num[1] = 1 当 2 &amp;lt;= 2 * i &amp;lt;= n 时，nums[2 * i] = nums[i] 当 2 &amp;lt;= 2 * i + 1 &amp;lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1] 返回生成数组 nums 中的最大值。 思路 # 模拟 # 打表 # 代码 # 模拟 # class Solution { public int getMaximumGenerated(int n) { if (n == 0) return 0; int[] array = new int[n + 1]; for (int i = 2; i &amp;lt;= n; i++) { if (i % 2 == 0) array[i] = array[i/2]; else array[i] = array[(i-1)/2] + array[(i-1)/2+1]; } int ans = -1; for (int num: array) ans = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1652.-Defuse-the-Bomb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1652.-Defuse-the-Bomb/</guid>
      <description>1652. Defuse the Bomb # 题目 # 你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k &amp;gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &amp;lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 思路 # 模拟 # 前缀和 # 代码 # 模拟 # class Solution { public int[] decrypt(int[] code, int k) { int[] ans = new int[code.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1662.-Check-If-Two-String-Arrays-are-Equivalent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1662.-Check-If-Two-String-Arrays-are-Equivalent/</guid>
      <description>1662. Check If Two String Arrays are Equivalent # 题目 # 给定两个字符串数组word1和word2。如果两个数组表示的字符串相同，返回true，否则返回false。 数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。 思路 # 模拟 # 代码 # 模拟-双指针 # class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { int i = 0, p = 0; int j = 0, q = 0; while (i &amp;lt; word1.length &amp;amp;&amp;amp; j &amp;lt; word2.length) { if (word1[i].charAt(p++) != word2[j].charAt(q++)) return false; if (p == word1[i].length()) { i++; p = 0; } if (q == word2[j].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1669.-Merge-in-Between-Linked-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1669.-Merge-in-Between-Linked-Lists/</guid>
      <description>1669. Merge in Between Linked Lists # 题目 # 给定两个链表list1和list2，它们包含的元素分别为n个和m个。
将list1中下标从a到b的全部节点都删除，并将list2接在被删除节点的位置。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) { ListNode ptrA = list1, ptrB = list1; for (int i=0; i&amp;lt;a-1; i++) ptrA = ptrA.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1670.-Design-Front-Middle-Back-Queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1670.-Design-Front-Middle-Back-Queue/</guid>
      <description>1670. Design Front Middle Back Queue # 题目 # 请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。
请你完成 FrontMiddleBack 类：
FrontMiddleBack() 初始化队列。 void pushFront(int val) 将 val 添加到队列的 最前面 。 void pushMiddle(int val) 将 val 添加到队列的 正中间 。 void pushBack(int val) 将 val 添加到队里的 最后面 。 int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 思路 # 代码 # class FrontMiddleBackQueue { private class ListNode { int val; ListNode prev; ListNode next; ListNode(int value, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1672.-Richest-Customer-Wealth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1672.-Richest-Customer-Wealth/</guid>
      <description> 1672. Richest Customer Wealth # 题目 # 给定 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i 位客户在第 j 家银行托管的资产数量。 客户的 资产总量 是其在各家银行托管的资产数量之和。最富有客户是 资产总量 最大的客户。 返回最富有客户所拥有的 资产总量 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int maximumWealth(int[][] accounts) { int ans = 0; for (int[] account: accounts) { int wealth = 0; for (int val: account) wealth += val; ans = Math.max(ans, wealth); } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1678.-Goal-Parser-Interpretation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1678.-Goal-Parser-Interpretation/</guid>
      <description>1678. Goal Parser Interpretation # 题目 # 请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 &amp;quot;G&amp;quot;、&amp;quot;()&amp;quot; 和/或 &amp;quot;(al)&amp;quot; 按某种顺序组成。Goal 解析器会将 &amp;quot;G&amp;quot; 解释为字符串 &amp;quot;G&amp;quot;、&amp;quot;()&amp;quot; 解释为字符串 &amp;quot;o&amp;quot; ，&amp;quot;(al)&amp;quot; 解释为字符串 &amp;quot;al&amp;quot; 。然后，按原顺序将经解释得到的字符串连接成一个字符串。 给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String interpret(String command) { String ans = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; command.length(); ) { switch (command.charAt(i++)) { case &amp;#39;G&amp;#39;: ans += &amp;#34;G&amp;#34;; break; case &amp;#39;(&amp;#39;: if (command.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1684.-Count-the-Number-of-Consistent-Strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1684.-Count-the-Number-of-Consistent-Strings/</guid>
      <description>1684. Count the Number of Consistent Strings # 题目 # 给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。 请你返回 words 数组中 一致字符串 的数目。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int countConsistentStrings(String allowed, String[] words) { Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; sllowed.length(); i++) set.add(allowed.charAt(i)); int cnt = 0; for (String word: words) { cnt++; for (int i = 0; i &amp;lt; word.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1688.-Count-of-Matches-in-Tournament/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1688.-Count-of-Matches-in-Tournament/</guid>
      <description>1688. Count of Matches in Tournament # 题目 # 给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制： 如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。 如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。 返回在比赛中进行的配对次数，直到决出获胜队伍为止。 思路 # 模拟 # 脑筋急转弯 # 共有 n 支队伍，每场比赛淘汰一支，最终剩下一支冠军队。 即有 n−1 支队伍需要通过 n−1 场比赛被淘汰。 代码 # 模拟 # class Solution { public int numberOfMatches(int n) { int ans = 0; while (n !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1694.-Reformat-Phone-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1694.-Reformat-Phone-Number/</guid>
      <description>1694. Reformat Phone Number # 题目 # 给你一个字符串形式的电话号码 number 。number 由数字、空格 &#39; &#39;、和破折号 &#39;-&#39; 组成。 请你按下述方式重新格式化电话号码。 首先，删除 所有的空格和破折号。 其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块： 2 个数字：单个含 2 个数字的块。 3 个数字：单个含 3 个数字的块。 4 个数字：两个分别含 2 个数字的块。 最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。 返回格式化后的电话号码。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String reformatNumber(String number) { String ans = &amp;#34;&amp;#34;; String digits = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; number.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1700.-Number-of-Students-Unable-to-Eat-Lunch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1700.-Number-of-Students-Unable-to-Eat-Lunch/</guid>
      <description>1700. Number of Students Unable to Eat Lunch # 题目 # 学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：
如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。 否则，这名学生会 放弃这个三明治 并回到队列的尾部。 这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。 给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队列里第 j 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。
思路 # 模拟 计数 代码 # 模拟 # class Solution { public int countStudents(int[] students, int[] sandwiches) { /** 初始化三明治 */ Stack&amp;lt;Integer&amp;gt; sandwichesStack = new Stack&amp;lt;&amp;gt;(); for (int i = sandwiches.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1704.-Determine-if-String-Halves-Are-Alike/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1704.-Determine-if-String-Halves-Are-Alike/</guid>
      <description>1704. Determine if String Halves Are Alike # 题目 # 给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。 两个字符串 相似 的前提是它们都含有相同数目的元音（&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39;，&#39;A&#39;，&#39;E&#39;，&#39;I&#39;，&#39;O&#39;，&#39;U&#39;）。注意，s 可能同时含有大写和小写字母。 如果 a 和 b 相似，返回 true ；否则，返回 false 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean halvesAreAlike(String s) { int numVowelFront = 0, numVowelBack = 0; for(int i = 0; i &amp;lt; s.length() / 2; i++) { if (&amp;#34;aeiouAEIOU&amp;#34;.contains(String.valueOf(s.charAt(i)))) numVowelFront++; } for(int i = s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1716.-Calculate-Money-in-Leetcode-Bank/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1716.-Calculate-Money-in-Leetcode-Bank/</guid>
      <description> 1716. Calculate Money in Leetcode Bank # 题目 # Hercy 想要为购买第一辆车存钱。他每天都往力扣银行里存钱。 最开始，他在周一的时候存入1块钱。从周二到周日，他每天都比前一天多存入1块钱。在接下来每一个周一，他都会比前一个周一多存入1块钱。 给定n，返回在第n天结束的时候他在力扣银行总共存了多少块钱。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int totalMoney(int n) { int N = n / 7, r = n % 7; int a1 = (1 + 7) * 7 / 2; int an = (N + N + 6) * 7 / 2; int ans = N * (a1 + an) / 2; if (r &amp;gt; 0) ans += (N + 1 + N + 1 + r - 1) * r / 2; return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1720.-Decode-XORed-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1720.-Decode-XORed-Array/</guid>
      <description>1720. Decode XORed Array # 题目 # 未知整数数组 arr 由 n 个非负整数组成。
经编码后变为长度为 n - 1 的另一个整数数组 encoded，其中 encoded[i] = arr[i] XOR arr[i + 1]。例如 arr = [1, 0, 2, 1] 经编码后得到 encoded = [1, 2, 3]。
给定编码后的数组 encoded 和原数组 arr 的第一个元素 first (arr[0])。
解码返回原数组 arr，可以证明答案存在并且是唯一的。
思路 # 代码 # class Solution { public int[] decode(int[] encoded, int first) { int[] ans = new int[encoded.length + 1]; ans[0] = first; for (int i = 1; i &amp;lt; ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1721.-Swapping-Nodes-in-A-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1721.-Swapping-Nodes-in-A-Linked-List/</guid>
      <description>1721. Swapping Nodes in A Linked List # 题目 # 给定链表头节点head和一个整数k
交换链表正数第k个节点和倒数第k个节点的值后，返回链表的头节点（链表从1开始索引）
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution{ public ListNode locateForward(ListNode head, int k) { ListNode sentinel = new ListNode(-1, head); ListNode ptr = sentinel; for (int i=0; i&amp;lt;k; i++) ptr = ptr.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1725.-Number-Of-Rectangles-That-Can-Form-The-Largest-Square/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1725.-Number-Of-Rectangles-That-Can-Form-The-Largest-Square/</guid>
      <description>1725. Number Of Rectangles That Can Form The Largest Square # 题目 # 给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。 如果存在 k 同时满足 k &amp;lt;= li 和 k &amp;lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。 设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。 请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int countGoodRectangles(int[][] rectangles) { int maxLen = 0, ans = 0; for (int[] rectangle: rectangles) { int width = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1732.-Find-the-Highest-Altitude/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1732.-Find-the-Highest-Altitude/</guid>
      <description>1732. Find the Highest Altitude # 题目 # 有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。 给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 &amp;lt;= i &amp;lt; n）。请你返回 最高点的海拔 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int largestAltitude(int[] gain) { int altitude = 0, maximum = 0; for (int diff: gain) { altitude += diff; maximum = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1736.-Latest-Time-by-Replacing-Hidden-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1736.-Latest-Time-by-Replacing-Hidden-Digits/</guid>
      <description>1736. Latest Time by Replacing Hidden Digits # 题目 # 给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。 有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。 替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String maximumTime(String time) { char[] ans = time.toCharArray(); if (ans[0] == &amp;#39;?&amp;#39;) ans[0] = ans[1] == &amp;#39;?&amp;#39; || ans[1] &amp;lt; &amp;#39;4&amp;#39; ? &amp;#39;2&amp;#39; : &amp;#39;1&amp;#39;; if (ans[1] == &amp;#39;?&amp;#39;) ans[1] = ans[0] == &amp;#39;2&amp;#39; ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1748.-Sum-of-Unique-Elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1748.-Sum-of-Unique-Elements/</guid>
      <description>1748. Sum of Unique Elements # 题目 # 给定整数数组 nums，数组中唯一元素是那些只出现 恰好一次 的元素。 返回 nums 中唯一元素的 和。 1 &amp;lt;= nums[i] &amp;lt;= 100 思路 # 哈希 # 代码 # 哈希 # class Solution { public int sumOfUnique(int[] nums) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int num: nums) { if (map.containsKey(num) == false) map.put(num, 1); else map.put(num, map.get(num) + 1); } int ans = 0; for (int num: nums) { if (map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1768.-Merge-Strings-Alternatively/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1768.-Merge-Strings-Alternatively/</guid>
      <description>1768. Merge Strings Alternatively # 题目 # 给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。 返回 合并后的字符串 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String mergeAlternatively(String word1, String word2) { char[] arr = new char[word1.length() + word2.length()]; int ptr1 = 0, ptr2 = 0, ptr = 0; while (ptr &amp;lt; arr.length) { if (ptr1 == word1.length()) arr[ptr++] = word2.charAt(ptr2++); else if (ptr2 == word2.length()) arr[ptr++] = word1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1773.-Count-Items-Matching-a-Rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1773.-Count-Items-Matching-a-Rule/</guid>
      <description>1773. Count Items Mathcing a Rule # 题目 # 给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。 另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。 如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ： ruleKey == &amp;quot;type&amp;quot; 且 ruleValue == typei 。 ruleKey == &amp;quot;color&amp;quot; 且 ruleValue == colori 。 ruleKey == &amp;quot;name&amp;quot; 且 ruleValue == namei 。 统计并返回 匹配检索规则的物品数量 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int countMatches(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; items, String ruleKey, String ruleValue) { int count = 0; for (List&amp;lt;String&amp;gt; item: items) { switch (ruleKey) { case &amp;#34;type&amp;#34; : if (item.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1784.-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1784.-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/</guid>
      <description>1784. Check if Binary String Has at Most One Segment of Ones # 题目 # 给你一个二进制字符串 s ，该字符串 不含前导零 。 如果 s 包含 零个或一个由连续的 &#39;1&#39; 组成的字段 ，返回 true 。否则，返回 false 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean checkOnesSegment(String s) { boolean warning = false; for (int i = 0; i &amp;lt; s.length(); i++) { if (s.charAt(i) == &amp;#39;0&amp;#39;) warning = true; else if (warning) return false; } return true; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1790.-Check-if-One-String-Swap-Can-Make-Strings-Equal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1790.-Check-if-One-String-Swap-Can-Make-Strings-Equal/</guid>
      <description>1790. Check if One String Swap Can Make Strings Equal # 题目 # 给定长度相等的两个字符串 s1 和 s2。 一次字符串交换操作的步骤为：选出某个字符串中的两个下标，并交换这两个下标对应的字符。 如果对其中一个字符串执行最多一次字符串交换就可以使两个字符串相等，返回true；否则返回false 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean areAlmostEqual(String s1, String s2) { if (s1.length() != s2.length()) return false; int left = -1, right = -1; for (int i = 0; i &amp;lt; s1.length(); i++) { if (s1.charAt(i) != s2.charAt(i)) { if (left == -1) left = i; else if (right == -1) right = i; else return false; } } if (left == -1) return true; if (right == -1) return false; return s1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1791.-Find-Center-of-Star-Graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1700-to-1799/1791.-Find-Center-of-Star-Graph/</guid>
      <description>1791. Find Center of Star Graph # 题目 # 有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。 给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。 思路 # 模拟 # 欧拉回路 # 代码 # 模拟 # class Solution { public int findCenter(int[][] edges) { int[] edge1 = edges[0], edge2 = edges[1]; if (edge2[0] == edge1[0] || edge2[0] == edge1[1]) return edge2[0]; return edge2[1]; } } 欧拉回路 # 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1816.-Truncate-Sentence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1816.-Truncate-Sentence/</guid>
      <description>1816. Truncate Sentence # 题目 # 句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。 例如，&amp;quot;Hello World&amp;quot;、&amp;quot;HELLO&amp;quot; 和 &amp;quot;hello world hello world&amp;quot; 都是句子。 给你一个句子 s 和一个整数 k ，请你将 s 截断 ，使截断后的句子仅含 前 k 个单词。返回 截断 s** 后得到的句子*。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String truncateSentence (String s, int k) { char[] charArray = s.toCharArray(); String ans = &amp;#34;&amp;#34;; for (int i = 0, cnt = 0; i &amp;lt; charArray.length &amp;amp;&amp;amp; cnt &amp;lt; k; i++) { if (charArray[i] == &amp;#39; &amp;#39; &amp;amp;&amp;amp; ++cnt == k) return ans; ans += String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1822.-Sign-of-the-Product-of-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1822.-Sign-of-the-Product-of-an-Array/</guid>
      <description>1822. Sign of the Product of an Array # 题目 # 给定整数数组 nums，令product为数组nums中所有元素值的乘积。 返回乘积的符号。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int arraySign(int[] nums) { int ans = 1; for (int num: nums) { if (num == 0) return 0; else if (num &amp;lt; 0) ans *= -1; } return ans; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1836.-Remove-Duplicates-From-an-Unsorted-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1836.-Remove-Duplicates-From-an-Unsorted-Linked-List/</guid>
      <description>1836. Remove Duplicates from An Unsorted Linked List # 题目 # 给定链表头节点 head，找到链表中所有出现 多于一次 的元素，并删除这些元素所在的节点。返回删除后的链表。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicatesUnsorted(ListNode head) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); ListNode ptr = head; while (ptr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1900-to-1999/1991.-Find-the-Middle-Index-in-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1900-to-1999/1991.-Find-the-Middle-Index-in-Array/</guid>
      <description>1999. Find the Middle Index in Array # 题目 # 给定下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （即所有可能中间位置下标最小的一个）。 中间位置 middleIndex 是满足 nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1] 的数组下标。 如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ，右边部分的和定义为 0 。 返回满足上述条件 最左边 的 middleIndex ，若不存在这样的中间位置，返回 -1 。 思路 # 前缀和 # 代码 # 前缀和 # class Solution { public int findMiddleIndex(int[] nums) { int total = 0; for(int num: nums) total += num; int prefix = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2000.-Reverse-Prefix-of-Word/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2000.-Reverse-Prefix-of-Word/</guid>
      <description>2000. Reverse Prefix of Word # 题目 # 给定下标从 0 开始的字符串 word 和一个字符 ch。 找出 ch 第一次出现的下标 i，反转 word 中从下标 0 开始、直到下标 i 结束的字符段。 若 word 中不存在字符 ch，无需进行任何操作。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String reversePrefix(String word, char ch) { int ptr = 0; while (ptr &amp;lt; word.length() &amp;amp;&amp;amp; word.charAt(ptr) != ch) ptr++; if (ptr == word.length()) return word; char[] charArray = word.toCharArray(); for (int i = 0, j = ptr; i &amp;lt; j; i++, j--) { Character temp = charArray[i]; charArray[i] = charArray[j]; charArray[j] = temp; } return String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2006.-Count-Number-of-Pairs-With-Absolute-Difference-K/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2006.-Count-Number-of-Pairs-With-Absolute-Difference-K/</guid>
      <description>2000. Reverse Prefix of Word # 题目 # 给定整数数组 nums 和一个整数 k。 返回数对 (i, j) 的数目，满足 i &amp;lt; j 且 |nums[i] - nums[j]| == k。 1 &amp;lt;= nums[i] &amp;lt;= 100 1 &amp;lt;= k &amp;lt;= 99 思路 # 哈希 # 代码 # 哈希 # class Solution { public int countKDifference(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int ans = 0; for (int num: nums) { ans += map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2016.-Maximum-Difference-Between-Increasing-Elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2016.-Maximum-Difference-Between-Increasing-Elements/</guid>
      <description>2016. Maximum Difference Between Increasing Elements # 题目 # 给定下标从 0 开始的整数数组 nums，该数组的大小为 n。 计算 nums[j] - nums[i] 能求得的最大差值，其中 0 &amp;lt;= i &amp;lt; j &amp;lt; n 且 nums[i] &amp;lt; nums[j]。 返回 最大差值。如果不存在满足要求的 i 和 j，返回 -1。 思路 # 模拟 # 类似 买卖股票的最佳时机 代码 # 模拟 # class Solution { public int maximumDifference(int[] nums) { int ans = -1, maxVal = nums[0]; for (int num: nums) { minVal = Math.min(minVal, num); ans = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2022.-Convert-1D-Array-into-2D-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2022.-Convert-1D-Array-into-2D-Array/</guid>
      <description> 2022. Convert 1D Array into 2D Array # 题目 # 给定下标从 0 开始的一维整数数组 original 和两个整数 m 和 n。 使用original中所有元素创建一个m行n列的二维数组。 根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，返回一个空的二维数组。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int[][] construct2DArray(int[] original, int m, int n) { if (original.length != m * n) return new int[0][0]; int[][] ans = new int[m][n]; for (int i = 0; i &amp;lt; original.length; i++0) { int row = i / n, col = i % n; ans[row][col] = original[i]; } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2046.-Sort-Linked-List-Already-Sorted-Using-Absolute-Values/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2046.-Sort-Linked-List-Already-Sorted-Using-Absolute-Values/</guid>
      <description>2046. Sort Linked List Already Sorted Using absolute Values # 题目 # 给定链表头结点 head，该链表根据结点的 绝对值 进行 升序 排序，返回重新根据 结点的值 进行 升序 排序的链表。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode sortLinkedList(ListNode head) { ListNode sentinel = new ListNode(-1, head); ListNode ptr = head; while (ptr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2047.-Number-of-Valid-Words-in-a-Sentence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2047.-Number-of-Valid-Words-in-a-Sentence/</guid>
      <description>2047. Number of Valid Words in a Sentence # 题目 # 句子仅由小写字母（&#39;a&#39; 到 &#39;z&#39;）、数字（&#39;0&#39; 到 &#39;9&#39;）、连字符（&#39;-&#39;）、标点符号（&#39;!&#39;、&#39;.&#39; 和 &#39;,&#39;）以及空格（&#39; &#39;）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 &#39; &#39; 分隔。 如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词： 仅由小写字母、连字符和/或标点（不含数字）组成。 至多一个 连字符 &#39;-&#39; 。如果存在，连字符两侧应当都存在小写字母（&amp;quot;a-b&amp;quot; 是一个有效单词，但 &amp;quot;-ab&amp;quot; 和 &amp;quot;ab-&amp;quot; 不是有效单词）。 至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。 这里给出几个有效单词的例子：&amp;quot;a-b.&amp;quot;、&amp;quot;afad&amp;quot;、&amp;quot;ba-c&amp;quot;、&amp;quot;a!&amp;quot; 和 &amp;quot;!&amp;quot; 。 给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean isValid(String token) { if (token.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2058.-Find-the-Minimum-and-Maximum-Number-of-Nodes-Between-Critical-Points/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2058.-Find-the-Minimum-and-Maximum-Number-of-Nodes-Between-Critical-Points/</guid>
      <description>2058. Find the Minimum and Maximum Number of Nodes Between Critical Points # 题目 # 链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。
如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个 局部极大值点 。
如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个 局部极小值点 。
注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。
给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。
思路 # 在第一个节点存在的情况下，每遇到一个新的临界点，maxDistance 在原有基础上递增距离，minDistance 重新计算。 maxDistance 是所有临界点分段的距离之和。 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2073.-Time-Needed-to-Buy-Tickets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2073.-Time-Needed-to-Buy-Tickets/</guid>
      <description>2073. Time Needed to Buy Tickets # 题目 # 有 n 个人前来排队买票，其中第 0 人站在队伍 最前方，第 (n - 1) 人站在队伍 最后方。
给定下标从 0 开始的整数数组 tickets，数组长度为 n，其中第 i 人想要购买的票数为 tickets[i]。
每个人买票都需要用掉 恰好 1 秒。一个人 一次只能买一张票，如果需要购买更多票，他必须走到 队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要的票，那他将会 离开 队伍。
返回位于位置 k（下标从 0 开始）的人完成买票需要的时间。
思路 # 代码 # class Solution { public int timeRequiredToBuy(int[] tickets, int k) { int ans = 0; for (int i = 0; i &amp;lt; k; i++) ans += Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2074.-Reverse-Nodes-in-Even-Length-Groups/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2074.-Reverse-Nodes-in-Even-Length-Groups/</guid>
      <description>2074. Reverse Nodes in Even Length Groups # 题目 # 给定链表头结点 head。
链表中的结点按照 按顺序 划分为若干 非空 组。这些非空组的长度构成一个自然数序列 {1, 2, 3, 4, ...}。一个组的 长度 就是组中分配到的结点数目。换言之：
结点 1 分配给第一组 结点 2 分配给第二组 结点 4、5、6 分配给第三组，以此类推 注意，最后一组的长度可能小于或等于 1 + 倒数第二组的长度。
反转 每个 偶数长度 组中的结点，并返回修改后链表的头结点 head。
思路 # 代码 # class Solution { public void reverseList(ListNode beforeHead, ListNode tail) { /** (beforeHead, tail] 要求 beforeHead != tail */ if (beforeHead == tail) return; ListNode afterTail = tail.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2095.-Delete-the-Middle-Node-of-A-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2000-to-2099/2095.-Delete-the-Middle-Node-of-A-Linked-List/</guid>
      <description>2095. Delete the Middle Node of A Linked List # 题目 # 给定链表头节点head，删除链表的中间节点，并返回修改后的链表头节点head。
长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteMiddle(ListNode head) { if (head == null) return null; ListNode sentinel = new ListNode(-1, head); ListNode middle = sentinel, fast = sentinel; while (fast !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2100-to-2199/2130.-Maximum-Twin-Sum-of-A-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2100-to-2199/2130.-Maximum-Twin-Sum-of-A-Linked-List/</guid>
      <description>2130. Maximum Twin Sum of A Linked List # 题目 # 在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &amp;lt;= i &amp;lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。
比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。 孪生和 定义为一个节点和它孪生节点两者值之和。
给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2100-to-2199/2169.-Count-Operations-to-Obtain-Zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2100-to-2199/2169.-Count-Operations-to-Obtain-Zero/</guid>
      <description> 2169. Count Operations to Obtain Zero # 题目 # 给你两个 非负 整数 num1 和 num2。
每一步 操作 中，如果 num1 &amp;gt;= num2 ，你必须用 num1 减 num2 ；否则，你必须用 num2 减 num1 。
返回使 num1 = 0 或 num2 = 0 的 操作数 。
思路 # 模拟 代码 # class Solution { public int countOperations(int num1, int num2) { int step = 0; while (num != 0 &amp;amp;&amp;amp; num2 != 0) { if (num1 &amp;gt;= num2) num1 -= num2; else num2 -= num1; step += 1; } return step; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2100-to-2199/2181.-Merge-Nodes-in-Between-Zeros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2100-to-2199/2181.-Merge-Nodes-in-Between-Zeros/</guid>
      <description>2181. Merge Nodes in Between Zeros # 题目 # 给定链表头节点 head ，该链表包含由 0 分隔开的一连串整数。链表的 开端 和 末尾 的节点都满足 Node.val == 0 。
对于每两个相邻的 0 ，之间的所有节点合并为一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。
返回修改后链表的头节点 head 。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode mergeNodes(ListNode head) { ListNode sentinel = new ListNode(-1, head); ListNode ptr = sentinel; while (ptr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2220.-Minimum-Bit-Flips-to-Convert-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2220.-Minimum-Bit-Flips-to-Convert-Number/</guid>
      <description> 2220. Minimum Bit Flips to Convert Number # 题目 # 一次 位翻转 定义为将数字 x 二进制位中的一个位进行 翻转 操作，即将 0 变成 1，或者将 1 变成 0。
给定两个整数 start 和 goal，返回将 start 转变为 goal 的 最少位翻转 次数。
思路 # 代码 # class Solution { public int minBitFlips(int start, int goal) { int xor = start ^ goal; int hammingDistance = 0; for (int i = 31; i &amp;gt;= 0; i--) { if (((xor &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) hammingDistance += 1; } return hammingDistance; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2235.-Add-Two-Integers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2235.-Add-Two-Integers/</guid>
      <description> 2235. Add Two Integers # 题目 # 给定两个整数 num1 和 num2，返回这两个整数的和。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int sum(int num1, int num2) { return num1 + num2; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2236.-Root-Equals-Sum-of-Children/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2236.-Root-Equals-Sum-of-Children/</guid>
      <description> 2236. Root Equals Sum of Children # 题目 # 给定二叉树的根节点 root，该二叉树恰由三个节点组成：根节点、左子节点、右子节点。
如果根节点值等于两个子节点值值和，返回 true，否则返回 false。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean checkTree(TreeNode root) { return root.val == root.left.val + root.right.val; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2289.-Steps-to-Make-Array-Non-decreasing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2289.-Steps-to-Make-Array-Non-decreasing/</guid>
      <description>2289. Steps to Make Array Non-decreasing # 题目 # 给定一个下标从 0 开始的整数数组 nums。在一步操作中，移除所有满足 nums[i-1] &amp;gt; nums[i] 的 nums[i]，其中 0 &amp;lt; i &amp;lt; nums.length。
重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。
思路 # 代码 # class Solution { /** 观察: 如果一个结点的左侧结点未发生变化，则该结点在本轮不会被删除 * 推论: 仅有被删除的结点会触发下一轮删除。当某结点被删除时，考虑是否将被删除结点的下一个结点纳入下一轮删除的列表里 */ private class ListNode { public int val; public ListNode prev; public ListNode next; ListNode(int val, ListNode prev, ListNode next) { this.val = val; this.prev = prev; this.next = next; } } public int totalSteps(int[] nums) { ListNode sentinel = new ListNode(-1, null, null); sentinel.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2296.-Design-A-Text-Editor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2200-to-2299/2296.-Design-A-Text-Editor/</guid>
      <description>2296. Design A Text Editor # 题目 # 请设计一个带光标的文本编辑器，它可以实现以下功能：
添加：在光标处添加文本。 删除：在光标处删除文本。 移动：将光标往左或往右移动。 当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，即任何时候 0 &amp;lt;= cursor.position &amp;lt;= currentText.length 都成立。
请实现 TextEditor 类：
TextEditor() 用空文本初始化对象。 void addText(String text) 将 text 添加到光标所在位置。添加完后光标在 text 的右边。 int deleteText(int k) 删除光标左边 k 个字符。返回实际删除的字符数目。 String cursorLeft(int k) 将光标向左移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。 String cursorRight(int k) 将光标向右移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。 思路 # 代码 # class TextEditor { private class ListNode { public char character; public ListNode prev; public ListNode next; ListNode (char character, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2319.-Check-if-Matrix-is-X-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2319.-Check-if-Matrix-is-X-Matrix/</guid>
      <description>2319. Check if Matrix Is X-Matrix # 题目 # X 矩阵 是满足下列条件的方阵 矩阵对角线上所有元素都 非零 非对角线元素均 为零 给定 n 阶方阵 grid，判断 grid 是否为 X 矩阵 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean checkXMatrix(int[][] grid) { boolean valid = true; for (int i = 0; i &amp;lt; grid.length; i++) { for (int j = 0; j &amp;lt; grid.length; j++) { if (i == j) valid &amp;amp;= grid[i][j] !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2325.-Decode-the-Message/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2325.-Decode-the-Message/</guid>
      <description>2325. Decode the Message # 题目 # 给定字符串 key 和 message ，分别表示 密钥 和 密文。解密步骤如下：
使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。 将替换表与普通英文字母表对齐，形成 对照表。 按照对照表 替换 message 中的每个字母。 空格 &#39; &#39; 保持不变。 例如，key = &amp;quot;happy boy&amp;quot;（实际的加密密钥会包含字母表中每个字母 至少一次），得到部分对照表（&#39;h&#39; -&amp;gt; &#39;a&#39;、&#39;a&#39; -&amp;gt; &#39;b&#39;、&#39;p&#39; -&amp;gt; &#39;c&#39;、&#39;y&#39; -&amp;gt; &#39;d&#39;、&#39;b&#39; -&amp;gt; &#39;e&#39;、&#39;o&#39; -&amp;gt; &#39;f&#39;）。
返回解密后的消息。
思路 # 哈希 # 代码 # 哈希 # class Solution { public String decodeMessage(String key, String message) { Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); char charPoint = &amp;#39;a&amp;#39;; for (int i = 0; i &amp;lt; key.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2326.-Spiral-Matrix-IV/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2326.-Spiral-Matrix-IV/</guid>
      <description> 2326. Spiral Matrix IV # 题目 # 给定两个整数 m 和 n，表示矩阵的维数。
另外给定一个整数链表的头节点 head。
生成并返回一个大小为 m x n 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵左上角开始、顺时针按螺旋顺序填充。如果还存在剩余的空格，则用 -1 填充。
思路 # 代码 # class Solution { public int getValue(ListNode[] ptr) { if (ptr[0] == null) return -1; int value = ptr[0].val; ptr[0] = ptr[0].next; return value; } public void helper(int[][] result, int top, int bottom, int left, int right, ListNode[] ptr) { if (top &amp;gt; bottom || left &amp;gt; right) return; if (top == bottom) { for (int j=left; j&amp;lt;=right; j++) result[top][j] = getValue(ptr); return; } if (left == right) { for (int i=top; i&amp;lt;=bottom; i++) result[i][left] = getValue(ptr); return; } else { for (int j=left; j&amp;lt;right; j++) result[top][j] = getValue(ptr); for (int i=top; i&amp;lt;bottom; i++) result[i][right] = getValue(ptr); for (int j=right; j&amp;gt;left; j--) result[bottom][j] = getValue(ptr); for (int i=bottom; i&amp;gt;top; i--) result[i][left] = getValue(ptr); } helper(result, top+1, bottom-1, left+1, right-1, ptr); } public int[][] spiralMatrix(int m, int n, ListNode head) { int[][] result = new int[m][n]; ListNode[] ptr = new ListNode[1]; ptr[0] = head; helper(result, 0, m-1, 0, n-1, ptr); return result; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2331.-Evaluate-Boolean-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2300-to-2399/2331.-Evaluate-Boolean-Binary-Tree/</guid>
      <description>2331. Evaluate Boolean Binary Tree # 题目 # 给定一棵 完整二叉树 的根，这棵树有以下特征：
叶子节点 要么值为 0 要么值为 1，其中 0 表示 false，1 表示 true。 非叶子节点 要么值为 2 要么值为 3，其中 2 表示逻辑或 OR，3表示逻辑与 AND。 计算一个节点的值方式如下：
如果节点是个叶子节点，那么节点的 值 为它本身，即 true 或 false。 否则，计算 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 运算。 返回根节点 root 的不二运算值。
完整二叉树 是每个节点有 0 个或者 2 个孩子的二叉树。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2400-to-2499/2460.-Apply-Operations-to-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2400-to-2499/2460.-Apply-Operations-to-an-Array/</guid>
      <description>2460. Apply Operations to an Array # 题目 # 给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。 对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令： 如果 nums[i] == nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。 在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。 例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。 返回结果数组。 注意 操作应当 依次有序 执行，而不是一次性全部执行。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int[] moveZeros(int[] nums) { int left = 0, right = 0; while (right &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/2400-to-2499/2487.-Remove-Nodes-From-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/2400-to-2499/2487.-Remove-Nodes-From-Linked-List/</guid>
      <description>2487. Remove Nodes From Linked List # 题目 # 给定链表头节点head，对于链表中的每个节点node，如果其右侧存在一个具有严格更大值的节点，则移除node。
返回修改后链表的头节点head。
思路 # 代码 # 反转&amp;amp;移除 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution{ public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode newHead = reverseList(head.next); head.next.next = head; head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/LCP/50.-%E5%AE%9D%E7%9F%B3%E8%A1%A5%E7%BB%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/LCP/50.-%E5%AE%9D%E7%9F%B3%E8%A1%A5%E7%BB%99/</guid>
      <description>LCP 50. 宝石补给 # 题目 # 欢迎各位勇者来到力扣新手村，在开始试炼之前，请各位勇者先进行「宝石补给」。
每位勇者初始都拥有一些能量宝石， gem[i] 表示第 i 位勇者的宝石数量。现在这些勇者们进行了一系列的赠送，operations[j] = [x, y] 表示在第 j 次的赠送中 第 x 位勇者将自己一半的宝石（需向下取整）赠送给第 y 位勇者。
在完成所有的赠送后，请找到拥有最多宝石的勇者和拥有最少宝石的勇者，并返回他们二者的宝石数量之差。
思路 # 模拟 代码 # class Solution { public int giveGem(int[] gem, int[][] operations) { for (int i = 0; i &amp;lt; operations.length; i++) { int giver = operations[i][0], claimant = operations[i][1]; int numGems = gem[giver] / 2; gem[giver] -= numGems; gem[claimant] += numGems; } int minGems = gem[0], maxGems = gem[0]; for (int i = 0; i &amp;lt; gem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/buttons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/buttons/</guid>
      <description> Buttons # Buttons are styled links that can lead to local page or external link.
Example # {{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}} Get Home Contribute TODO
将题目的URL替换为leetcode.com的相应链接 标记题目的difficulty 完善每道题目的analysis 融合Anki </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/columns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/columns/</guid>
      <description>Columns # Columns help organize shorter pieces of content horizontally for readability.
{{&amp;lt; columns &amp;gt;}} &amp;lt;!-- begin columns block --&amp;gt; # Left Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Mid Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Right Content Lorem markdownum insigne... {{&amp;lt; /columns &amp;gt;}} Example # Left Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/details/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/details/</guid>
      <description> Details # Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example # {{&amp;lt; details &amp;#34;Title&amp;#34; [open] &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} {{&amp;lt; details title=&amp;#34;Title&amp;#34; open=true &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} Title Markdown content # Lorem markdownum insigne&amp;hellip; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/expand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/expand/</guid>
      <description>Expand # Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.
Example # Default # {{&amp;lt; expand &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Expand ↕ Markdown content # Lorem markdownum insigne&amp;hellip; With Custom Label # {{&amp;lt; expand &amp;#34;Custom Label&amp;#34; &amp;#34;...&amp;#34; &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Custom Label ... Markdown content # Lorem markdownum insigne.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/hints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/hints/</guid>
      <description>Hints # Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{&amp;lt; hint [info|warning|danger] &amp;gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{&amp;lt; /hint &amp;gt;}} Example # Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/katex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/katex/</guid>
      <description>KaTeX # KaTeX shortcode let you render math typesetting in markdown document. See KaTeX
Example # {{&amp;lt; katex [display] [class=&amp;#34;text-center&amp;#34;] &amp;gt;}} f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi {{&amp;lt; /katex &amp;gt;}} \[f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi\] Display Mode Example # Here is some inline example: \(\pi(x)\) , rendered in the same line. And below is display example, having display: block \[f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi\] Text continues here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/mermaid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/mermaid/</guid>
      <description>Mermaid Chart # MermaidJS is library for generating svg charts and diagrams from text.
Override Mermaid Initialization Config
To override the initialization config for Mermaid, create a mermaid.json file in your assets folder!
Example # {{&amp;lt; mermaid [class=&amp;#34;text-center&amp;#34;]&amp;gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --&amp;gt; State2 note left of State2 : This is the note to the left.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/reference/tabs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/reference/tabs/</guid>
      <description>Tabs # Tabs let you organize content by context, for example installation instructions for each supported platform.
{{&amp;lt; tabs &amp;#34;uniqueid&amp;#34; &amp;gt;}} {{&amp;lt; tab &amp;#34;MacOS&amp;#34; &amp;gt;}} # MacOS Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Linux&amp;#34; &amp;gt;}} # Linux Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Windows&amp;#34; &amp;gt;}} # Windows Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; /tabs &amp;gt;}} Example # MacOS MacOS # This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/002.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/002.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95/</guid>
      <description>剑指 Offer II 002. 二进制加法 # 题目 # 给定两个01字符串a和b，计算它们的和，并以二进制字符串的形式输出。 输入为非空字符串且只包含数字1和0。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String addBinary(String a, String b) { String longer = a.length() &amp;gt; b.length() ? a : b, shorter = a.length() &amp;gt; b.length() ? b : a; int ptrLonger = longer.length() - 1, ptrShorter = shorter.length() - 1; char[] ans = longer.toCharArray(); int sum = 0, carry = 0; while (ptrShorter &amp;gt;= 0) { sum = longer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/041.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/041.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</guid>
      <description>剑指 Offer II 041. 滑动窗口的平均值 # 题目 # 给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。 实现 MovingAverage 类： MovingAverage(int size) 用窗口大小 size 初始化对象。 double next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。 思路 # 队列 # 代码 # 队列 # class MovingAverage { private Queue&amp;lt;Integer&amp;gt; queue; private int capacity; private int sum; public MovingAverage(int size) { this.queue = new LinkedList&amp;lt;&amp;gt;(); this.capacity = size; this.sum = 0; } public double next(int val) { if (this.queue.size() == this.capacity) this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/042.-%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/042.-%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</guid>
      <description>剑指 Offer II 042. 最近请求次数 # 题目 # 写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 每次对 ping 的调用都使用比之前更大的 t 值。 思路 # 队列 # 代码 # 队列 # class RecentCounter { private Queue&amp;lt;Integer&amp;gt; queue; public RecentCounter() { this.queue = new LinkedList&amp;lt;&amp;gt;(); } public int ping(int t) { queue.offer(t); while(queue.peek() &amp;lt; t - 3000) queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/058.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/058.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>剑指 Offer II 058. 左旋转字符串 # 题目 # 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。 请定义一个函数实现字符串左旋转操作的功能。 比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;quot;。 思路 # 三次翻转 # 代码 # 三次翻转 # class Solution { public void swap(char[] charArray, int i, int j) { char temp = charArray[i]; charArray[i] = charArray[j]; charArray[j] = temp; } public String reverseLeftWords(String s, int n) { char[] charArray = s.toCharArray(); for (int i = 0, j = charArray.length - 1; i &amp;lt; j; i++, j--) swap(charArray, i, j); for (int i = 0, j = charArray.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>剑指 Offer 06. 从尾到头打印链表 # 题目 # 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public void helper(ListNode head, List&amp;lt;Integer&amp;gt; resultList) { if (head == null) return; else if (head.next == null) resultList.add(head.val); else { helper(head.next, resultList); resultList.add(head.val); } } public int[] reversePrint(ListNode head) { List&amp;lt;Integer&amp;gt; resultList = new ArrayList&amp;lt;&amp;gt;(); helper(head, resultList); int[] result = new int[resultList.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>剑指 Offer 09. 用两个栈实现队列 # 题目 # 用两个栈实现一个队列。 队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。 (若队列中没有元素，deleteHead 操作返回 -1 ) 思路 # 代码 # class CQueue { Stack&amp;lt;Integer&amp;gt; inStack, outStack; public CQueue() { this.inStack = new Stack&amp;lt;&amp;gt;(); this.outStack = new Stack&amp;lt;&amp;gt;(); } public void appendTail(int value) { this.inStack.push(value); } public int deleteHead() { if (this.outStack.size() == 0 &amp;amp;&amp;amp; this.inStack.size() == 0) return -1; if (this.outStack.size() == 0) { while (this.inStack.size() != 0) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/10.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/10.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description> 剑指 Offer 10-I. 斐波那契数列 # 题目 # 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
思路 # 迭代 # 代码 # 迭代 # class Solution { public int fib(int n) { if (n == 0) return 0; if (n == 1) return 1; int one = 0, two = 1; for (int i = 2; i &amp;lt;= n; i++) { int temp = one % 1000000007 + two % 1000000007; one = two; two = temp; } return two % 1000000007; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description> 剑指 Offer 18. 删除链表的节点 # 题目 # 给定单链表的头指针和一个要删除的节点的值，定义一个函数删除该节点，返回删除后的链表的头节点。链表中节点的值互不相同。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode deleteNode(ListNode head, int val) { if (head.val == val) return head.next; ListNode ptr = head; while (ptr.next.val != val) ptr = ptr.next; ptr.next = ptr.next.next; return head; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description> 剑指 Offer 27. 二叉树的镜像 # 题目 # 给定一棵二叉树，输出其镜像。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { this.val = x; } } class Solution { public TreeNode mirrorTree(TreeNode root) { if (root == null || (root.left == null &amp;amp;&amp;amp; root.right == null)) return root; TreeNode temp = mirrorTree(root.left); root.left = mirrorTree(root.right); root.right = temp; return root; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>剑指 Offer 22. 对称的二叉树 # 题目 # 请实现一个函数，用来判断一棵二叉树是否是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { this.val = x; } } class Solution { public boolean isTwoSymmetric(TreeNode root1, TreeNode root2) { if (root1 == null) return root2 == null; if (root2 == null) return false; return (root1.val == root2.val) &amp;amp; isTwoSymmetric(root1.left, root2.right) &amp;amp; isTwoSymmetric(root1.right, root2.left); } public boolean isSymmetric(TreeNode root) { if (root == null) return true; return isTwoSymmetric(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/32.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/32.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>剑指 Offer 32. 从上到下打印二叉树 # 题目 # 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 思路 # 层序遍历 # 代码 # 层序遍历 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } class Solution { public int[] levelOrder(TreeNode root) { List&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); if (root != null) queue.offer(root); while (queue.size() != 0) { int layerSize = queue.size(); for (int i = 0; i &amp;lt; layerSize; i++) { TreeNode node = queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/55.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer/55.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description> 剑指 Offer 55. 二叉树的深度 # 题目 # 给定一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { this.val = x; } } class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-01.01.-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-01.01.-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</guid>
      <description>面试题 01.01. 判断字符是否唯一 # 题目 # 实现算法判断给定字符串 s 的所有字符是否全都不同。
s[i] 仅包含小写字母。
如果不使用额外的数据结构，会很加分。
思路 # 哈希 位运算 代码 # 哈希 # class Solution { public boolean isUnique(String astr) { int[] record = new int[26]; for (int i = 0; i &amp;lt; astr.length(); i++) if (++record[astr.charAt(i) - &amp;#39;a&amp;#39;] == 2) return false; return true; } } 致谢 # 珍珠好好吃
MAllk33</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-01.02.-%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-01.02.-%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</guid>
      <description>面试题 01.02. 判定是否互为字符重排 # 题目 # 给定两个由小写字母组成的字符串s1和s2。 判断其中一个字符串的字符经重排后能否变成另一个字符串。 思路 # 哈希 # 代码 # 哈希 # class Solution { public boolean CheckPermutation(String s1, String s2) { if (s1.length() != s2.length()) return false; char[] charArray1 = new char[26], charArray2 = new char[26]; for (int i = 0; i &amp;lt; s1.length(); i++) { charArray1[s1.charAt(i) - &amp;#39;a&amp;#39;] += 1; charArray2[s2.charAt(i) - &amp;#39;a&amp;#39;] += 1; } for (int i = 0; i &amp;lt; charArray1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-01.04.-%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-01.04.-%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</guid>
      <description>面试题 01.04. 回文排列 # 题目 # 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
回文串不一定是字典中的单词。
思路 # 若 s.length() 为奇数，只允许存在一个元素仅出现一次。 若 s.length() 为偶数，不允许出现存在次数为偶数的元素。 代码 # class Solution { public boolean canPermutePalindrome(String s) { Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; s.length(); i++) map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1); int numOdd = 0; for (Integer cnt: map.values()) if (cnt % 2 == 1) numOdd += 1; return s.length() % 2 == 0 ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-02.01.-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-02.01.-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid>
      <description> 面试题 02.01. 移除重复节点 # 题目 # 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode removeDuplicateNodes(ListNode head) { if (head == null) return null; HashSet&amp;lt;Integer&amp;gt; record = new HashSet&amp;lt;&amp;gt;(); ListNode ptr = head; while (ptr.next != null) { record.add(ptr.val); if (record.contains(ptr.next.val)) ptr.next = ptr.next.next; else ptr = ptr.next; } return head; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-03.03.-%E5%A0%86%E7%9B%98%E5%AD%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-03.03.-%E5%A0%86%E7%9B%98%E5%AD%90/</guid>
      <description>面试题 03.03. 堆盘子 # 题目 # 堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，就会堆另外一堆盘子。实现数据结构 SetOfStacks，模拟这种行为。SetOfStacks 应该由多个栈组成，并在在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和 SetOfStacks.pop() 应该与普通栈的操作方法相同 (即，pop 的返回值应该与只有一个栈时的情况一致)。此外，实现 popAt(int index) 方法，根据指定的子栈，执行 pop 操作。
当某个栈为空时，应删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1。
思路 # 代码 # class StackOfPlates { private class stackNode { public int val; public stackNode next; stackNode(int val, stackNode next) { this.val = val; this.next = next; } } private class Stack { private int size; private int capacity; private stackNode sentinel; Stack(int capacity) { this.size = 0; this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-03.04.-%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-03.04.-%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</guid>
      <description>面试题 03.04. 化栈为队 # 题目 # 实现一个 MyQueue 类，该类用两个栈实现一个队列。 思路 # 代码 # class MyQueue { Stack&amp;lt;Integer&amp;gt; inStack, outStack; /** Initialize your data structure here. */ public MyQueue() { this.inStack = new Stack&amp;lt;&amp;gt;(); this.outStack = new Stack&amp;lt;&amp;gt;(); } /** Push element x to the back of queue. */ public void push(int x) { this.inStack.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { if (this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-04.03.-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-04.03.-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 04.03. 特定深度节点链表 # 题目 # 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表。
返回一个包含所有深度的链表的数组。
思路 # 层序遍历变体 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode[] listOfDepth(TreeNode tree) { /* 用queue存储单链表头节点，而后将queue转为ListNode[] */ Queue&amp;lt;ListNode&amp;gt; ansQueue = new LinkedList&amp;lt;&amp;gt;(); /* 二叉树的层序遍历 */ Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-04.04.-%E6%A3%80%E6%9F%A5%E5%B9%B3%E8%A1%A1%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-04.04.-%E6%A3%80%E6%9F%A5%E5%B9%B3%E8%A1%A1%E6%80%A7/</guid>
      <description>面试题 04.04. 检查平衡性 # 题目 # 检查二叉树是否平衡 平衡二叉树的定义为: 任取一个节点，其两棵子树的高度差不超过 1 思路 # 递归 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { this.val = x; } } class Solution { public int depth(TreeNode root) { if (root == null) return 0; int leftDepth = depth(root.left); if (leftDepth == -1) return -1; int rightDepth = depth(root.right); if (rightDepth == -1) return -1; if (Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-05.07.-%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%8D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98-05.07.-%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%8D%A2/</guid>
      <description>面试题 05.07. 配对交换 # 题目 # 配对交换，编写代码，交换某个整数的奇数位和偶数位，尽量使用较少的指令。
即将位0与位1交换，位2与位3交换，以此类推。
思路 # 位运算 代码 # local picture # class Solution { public int exchangeBits(int num) { int odd = 1 &amp;lt;&amp;lt; 1, even = 1 &amp;lt;&amp;lt; 0; while (0 &amp;lt;= odd &amp;amp;&amp;amp; odd &amp;lt;= (1 &amp;lt;&amp;lt; 29)) { if (((num &amp;amp; odd) != 0) &amp;amp;&amp;amp; (num &amp;amp; even) == 0) || (num &amp;amp; odd) == 0 &amp;amp;&amp;amp; (num &amp;amp; even) != 0) { num ^= odd ^ even; } odd &amp;lt;= 2; even &amp;lt;= 2; } return num; } } global picture # class Solution { public int exchangeBits(int num) { return ((num &amp;amp; 0xaaaaaaaa) &amp;gt;&amp;gt; 1) | ((num &amp;amp; 0x55555555) &amp;lt;&amp;lt; 1); } } 致谢 # 我要出去乱说</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/topic/bit-operation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/topic/bit-operation/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/topic/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/topic/hidden/</guid>
      <description>This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem.</description>
    </item>
    
  </channel>
</rss>
