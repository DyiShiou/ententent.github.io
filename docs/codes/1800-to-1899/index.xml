<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/</link>
    <description>Recent content on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/docs/codes/1800-to-1899/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1816.-Truncate-Sentence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1816.-Truncate-Sentence/</guid>
      <description>1816. Truncate Sentence # 题目 # 句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。 例如，&amp;quot;Hello World&amp;quot;、&amp;quot;HELLO&amp;quot; 和 &amp;quot;hello world hello world&amp;quot; 都是句子。 给你一个句子 s 和一个整数 k ，请你将 s 截断 ，使截断后的句子仅含 前 k 个单词。返回 截断 s** 后得到的句子*。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String truncateSentence (String s, int k) { char[] charArray = s.toCharArray(); String ans = &amp;#34;&amp;#34;; for (int i = 0, cnt = 0; i &amp;lt; charArray.length &amp;amp;&amp;amp; cnt &amp;lt; k; i++) { if (charArray[i] == &amp;#39; &amp;#39; &amp;amp;&amp;amp; ++cnt == k) return ans; ans += String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1822.-Sign-of-the-Product-of-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1822.-Sign-of-the-Product-of-an-Array/</guid>
      <description>1822. Sign of the Product of an Array # 题目 # 给定整数数组 nums，令product为数组nums中所有元素值的乘积。 返回乘积的符号。 思路 # 模拟 # 代码 # 模拟 # class Solution { public int arraySign(int[] nums) { int ans = 1; for (int num: nums) { if (num == 0) return 0; else if (num &amp;lt; 0) ans *= -1; } return ans; } } 致谢 # 宫水三叶</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1836.-Remove-Duplicates-From-an-Unsorted-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1800-to-1899/1836.-Remove-Duplicates-From-an-Unsorted-Linked-List/</guid>
      <description>1836. Remove Duplicates from An Unsorted Linked List # 题目 # 给定链表头节点 head，找到链表中所有出现 多于一次 的元素，并删除这些元素所在的节点。返回删除后的链表。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicatesUnsorted(ListNode head) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); ListNode ptr = head; while (ptr !</description>
    </item>
    
  </channel>
</rss>
