<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/</link>
    <description>Recent content on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/docs/codes/1100-to-1199/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1108.-Defanging-an-IP-Address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1108.-Defanging-an-IP-Address/</guid>
      <description>1108. Defanging an IP Address # 题目 # 给定一个有效的IPV4地址address，返回这个IP地址的无效化版本。
无效化IP地址，就是用&amp;quot;[.]&amp;quot;代替了每个&amp;quot;.&amp;quot;。
思路 # 模拟 # 代码 # 模拟 # class Solution { public String defangIPaddr(String address) { char[] and = new char[address.length() + 6]; int ptrAns = 0, ptrAddress = 0; while (ptrAns &amp;lt; ans.length) { if (address.charAt(ptrAddress) != &amp;#39;.&amp;#39;) { ans[ptrAns++] = address.charAt(ptrAddress); } else { ans[ptrAns++] = &amp;#39;[&amp;#39;; ans[ptrAns++] = &amp;#39;.&amp;#39;; ans[ptrAns+=] = &amp;#39;]&amp;#39;; } ptrAddress++; } return String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1154.-Day-of-the-Year/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1154.-Day-of-the-Year/</guid>
      <description>1154. Day of the Year # 题目 # 给定字符串 date，按YYYY-MM-DD格式表示一个现行公元年法日期。
返回该日期是当年的第几天。
思路 # 模拟 # 打表 # 代码 # 模拟 # class Solution { public boolean isLeapYear(int year) { /** 能被4整除但不能被100整除的是闰年 * 能被400整除的是闰年 */ return (year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0) || year % 400 == 0; } public int dayOfYear(String date) { int year = Integer.parseInt(date.split(&amp;#34;-&amp;#34;)[0]); int month = Integer.parseInt(date.split(&amp;#34;-&amp;#34;)[1]); int day = Integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1171.-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1100-to-1199/1171.-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</guid>
      <description>1171. Remove Zero Sum Consecutive Nodes from Linked List # 题目 # 给定链表头节点 head ，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。
删除完毕后，返回最终结果链表的头节点。
思路 # 考察第 k 个链表结点，判断其是否位于某个 零子序列 中，只需通过检查第 k-1 个结点的前缀和在 &amp;gt;=k 结点处是否再次出现。 可以通过两次遍历链表，借助 HashMap 实现这一需求 第一趟遍历，计算每个结点的前缀和，并构建前缀和与最远结点的映射关系 第二趟遍历，从哨兵结点开始，从映射中查找当前前缀和对应的结点，若找到则移除之间的结点。 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeZeroSumSublists(ListNode head) { ListNode sentinel = new ListNode(0, head); Map&amp;lt;Integer, ListNode&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.</description>
    </item>
    
  </channel>
</rss>
