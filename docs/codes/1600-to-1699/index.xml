<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/</link>
    <description>Recent content on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/docs/codes/1600-to-1699/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1634.-Add-Two-Polynomials-Represented-as-Linked-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1634.-Add-Two-Polynomials-Represented-as-Linked-Lists/</guid>
      <description>1634. Add Two Polynomials Represented as Linked Lists # 题目 # 多项式链表是一种特殊形式的链表，每个结点表示多项式的一项。
每个结点有三个属性：
coefficient： 该项的系数 power：该项的指数 next：指向下一个结点的指针，如果当前结点为链表的最后一个结点则为 null 多项式链表是标准形式的，即多项式 严格 按指数 power 的递减顺序排列。系数 coefficient 为 0 的项需要省略。
给定两个多项式链表的头结点 poly1 和 poly2，返回它们的和的头结点。
思路 # 代码 # class PolyNode { int coefficient, power; PolyNode next = null; PolyNode() {} PolyNode(int x, int y) { this.coefficient = x; this.power = y; } PolyNode(int x, int y, PolyNode next) { this.coefficient = x; this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1669.-Merge-in-Between-Linked-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1669.-Merge-in-Between-Linked-Lists/</guid>
      <description>1669. Merge in Between Linked Lists # 题目 # 给定两个链表list1和list2，它们包含的元素分别为n个和m个。
将list1中下标从a到b的全部节点都删除，并将list2接在被删除节点的位置。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) { ListNode ptrA = list1, ptrB = list1; for (int i=0; i&amp;lt;a-1; i++) ptrA = ptrA.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1670.-Design-Front-Middle-Back-Queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/1600-to-1699/1670.-Design-Front-Middle-Back-Queue/</guid>
      <description>1670. Design Front Middle Back Queue # 题目 # 请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。
请你完成 FrontMiddleBack 类：
FrontMiddleBack() 初始化队列。 void pushFront(int val) 将 val 添加到队列的 最前面 。 void pushMiddle(int val) 将 val 添加到队列的 正中间 。 void pushBack(int val) 将 val 添加到队里的 最后面 。 int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 思路 # 代码 # class FrontMiddleBackQueue { private class ListNode { int val; ListNode prev; ListNode next; ListNode(int value, ListNode prev, ListNode next) { this.</description>
    </item>
    
  </channel>
</rss>
