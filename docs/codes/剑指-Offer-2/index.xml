<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/</link>
    <description>Recent content on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/002.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/002.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95/</guid>
      <description>剑指 Offer II 002. 二进制加法 # 题目 # 给定两个01字符串a和b，计算它们的和，并以二进制字符串的形式输出。 输入为非空字符串且只包含数字1和0。 思路 # 模拟 # 代码 # 模拟 # class Solution { public String addBinary(String a, String b) { String longer = a.length() &amp;gt; b.length() ? a : b, shorter = a.length() &amp;gt; b.length() ? b : a; int ptrLonger = longer.length() - 1, ptrShorter = shorter.length() - 1; char[] ans = longer.toCharArray(); int sum = 0, carry = 0; while (ptrShorter &amp;gt;= 0) { sum = longer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/041.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/041.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</guid>
      <description>剑指 Offer II 041. 滑动窗口的平均值 # 题目 # 给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。 实现 MovingAverage 类： MovingAverage(int size) 用窗口大小 size 初始化对象。 double next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。 思路 # 队列 # 代码 # 队列 # class MovingAverage { private Queue&amp;lt;Integer&amp;gt; queue; private int capacity; private int sum; public MovingAverage(int size) { this.queue = new LinkedList&amp;lt;&amp;gt;(); this.capacity = size; this.sum = 0; } public double next(int val) { if (this.queue.size() == this.capacity) this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/042.-%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/042.-%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</guid>
      <description>剑指 Offer II 042. 最近请求次数 # 题目 # 写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 每次对 ping 的调用都使用比之前更大的 t 值。 思路 # 队列 # 代码 # 队列 # class RecentCounter { private Queue&amp;lt;Integer&amp;gt; queue; public RecentCounter() { this.queue = new LinkedList&amp;lt;&amp;gt;(); } public int ping(int t) { queue.offer(t); while(queue.peek() &amp;lt; t - 3000) queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/058.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/%E5%89%91%E6%8C%87-Offer-2/058.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>剑指 Offer II 058. 左旋转字符串 # 题目 # 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。 请定义一个函数实现字符串左旋转操作的功能。 比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;quot;。 思路 # 三次翻转 # 代码 # 三次翻转 # class Solution { public void swap(char[] charArray, int i, int j) { char temp = charArray[i]; charArray[i] = charArray[j]; charArray[j] = temp; } public String reverseLeftWords(String s, int n) { char[] charArray = s.toCharArray(); for (int i = 0, j = charArray.length - 1; i &amp;lt; j; i++, j--) swap(charArray, i, j); for (int i = 0, j = charArray.</description>
    </item>
    
  </channel>
</rss>
