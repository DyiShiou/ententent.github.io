<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/</link>
    <description>Recent content on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/docs/codes/0100-to-0199/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0100.-Same-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0100.-Same-Tree/</guid>
      <description>100. Same Tree # 题目 # 给定两棵二叉树的根节点 p 和 q，判断这两棵树是否相同。
若两棵树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null) return q == null; if (q == null) return false; return (p.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0101.-Symmetric-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0101.-Symmetric-Tree/</guid>
      <description>101. Symmetric Tree # 题目 # 给定二叉树的根节点 root，检查它是否轴对称。
思路 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean checkTwoNodes(TreeNode node1, TreeNode2) { if (node1 == null &amp;amp;&amp;amp; node2 == null) return true; if (node1 == null &amp;amp;&amp;amp; node2 !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0102.-Binary-Tree-Level-Order-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0102.-Binary-Tree-Level-Order-Traversal/</guid>
      <description>102. Binary Tree Level Order Traversal # 题目 # 给定二叉树的根节点 root，返回其节点值的 层序遍历。
即逐层地，从左到右访问所有节点。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0103.-Binary-Tree-Zigzag-Level-Order-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0103.-Binary-Tree-Zigzag-Level-Order-Traversal/</guid>
      <description>103. Binary Tree Zigzag Level Order Traversal # 题目 # 给定二叉树的根节点 root，返回其节点值的 锯齿形层序遍历。
即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。
思路 # 双栈 代码 # 双栈 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Stack&amp;lt;TreeNode&amp;gt; leftStack = new Stack&amp;lt;&amp;gt;(); Stack&amp;lt;TreeNode&amp;gt; rightStack = new Stack&amp;lt;&amp;gt;(); leftStack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0104.-Maximum-Depth-of-BInary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0104.-Maximum-Depth-of-BInary-Tree/</guid>
      <description>104. Maximum Depth of Binary Tree # 题目 # 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
思路 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; return 1 + Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0107.-Binary-Tree-Level-Order-Traversal-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0107.-Binary-Tree-Level-Order-Traversal-II/</guid>
      <description>107. Binary Tree Level Order Traversal II # 题目 # 给定二叉树的根节点 root，返回其节点值 自底向上的层序遍历。
从叶子节点所在层到根节点所在的层，逐层从左向右遍历。
思路 # 队列的栈: 先建栈，后出栈 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Stack&amp;lt;Queue&amp;lt;TreeNode&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0110.-Balanced-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0110.-Balanced-Binary-Tree/</guid>
      <description>110. Balanced Binary Tree # 题目 # 给定一棵二叉树，判断其是否为高度平衡的二叉树。
高度平衡二叉树定义为：每个节点的左右两个子树的高度差的绝对值不超过1。
思路 # 编写代码的过程中会发现，需要类型分别为 boolean 和 int 的两个返回值，对应 以 root 为根节点的树是否高度平衡 和 以 root 为根节点的树的高度 鉴于树高为非负整数，故负整数可用于表示 以 root 为根节点的树非高度平衡 树的高度通过子树的高度计算得出。且负树高具有传递性。 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { /** 以 -1 表示 root 非高度平衡二叉树 */ public int depth(TreeNode root) { if (root == null) return 0; int leftDepth = depth(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0111.-Minimum-Depth-of-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0111.-Minimum-Depth-of-Binary-Tree/</guid>
      <description>111. Minimum Depth of Binary Tree # 题目 # 给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
思路 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0112.-Path-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0112.-Path-Sum/</guid>
      <description>112. Path Sum # 题目 # 给定二叉树的根节点 root 和一个表示目标和的整数 targetSum。判断该树上是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum。
叶子节点 是指没有子节点的节点。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0116.-Populating-Next-Right-Pointers-in-Each-Node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0116.-Populating-Next-Right-Pointers-in-Each-Node/</guid>
      <description>116. Populating Next Right Pointers in Each Node # 题目 # 给定一个 完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
思路 # 层序遍历 代码 # 层序遍历 # class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } } class Solution { public Node connect(Node root) { if (root == null) return null; Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0117.-Populating-Next-Right-Pointers-in-Each-Node-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0117.-Populating-Next-Right-Pointers-in-Each-Node-ii/</guid>
      <description>116. Populating Next Right Pointers in Each Node II # 题目 # 给定一个二叉树
struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
思路 # 层序遍历 代码 # 层序遍历 # class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } } class Solution { public Node connect(Node root) { if (root == null) return null; Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0136.-Single-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0136.-Single-Number/</guid>
      <description> 136. Single Number # 题目 # 给定一个 非空 整数数组 nums，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。
设计并实现线性时间复杂度的算法来解决此问题，且算法只使用常量额外空间。
思路 # x ^ x = 0、 x ^ 0 = x
代码 # class Solution { public int singleNumber(int[] nums) { int result = 0; for (int num: nums) result = result ^ num; return result; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0138.-Copy-List-with-Random-Pointer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0138.-Copy-List-with-Random-Pointer/</guid>
      <description>138. Copy List with Random Pointer # 题目 # 给定长度为 n 的链表，每个节点包含一个额外增加的随机指针 random，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。
思路 # 通过两次遍历实现深拷贝。
第一趟遍历，为新链表逐个生成节点，并构建新旧链表节点之间的对应关系。 第二趟遍历，为新链表深复制随机指针。 代码 # class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } class Solution { public Node copyRandomList(Node head) { Node sentinelOld = new Node(-1); sentinelOld.next = head; Node sentinelNew = new Node(-1); Node ptrOld = sentinelOld, ptrNew = sentinelNew; HashMap&amp;lt;Node, Node&amp;gt; correspond = new HashMap&amp;lt;Node, Node&amp;gt;(); while (ptrOld.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0141.-Linked-List-Cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0141.-Linked-List-Cycle/</guid>
      <description>141. Linked List Cycle # 题目 # 给定链表头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
思路 # 代码 # class ListNode { int val; ListNode next; ListNode (int x) { val = x; next = null; } } public class Solution { public boolean hasCycle(ListNode head) { ListNode slow=head, fast=head; while (fast != null &amp;amp;&amp;amp; fast.next != null) { fast = fast.next.next; slow = slow.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0142.-Linked-List-Cycle-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0142.-Linked-List-Cycle-ii/</guid>
      <description>142. Linked List Cycle II # 题目 # 给定链表头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
不允许修改 链表。
思路 # 设head至环入口距离为x，环入口至相遇处距离为y，相遇处至环入口距离为z assert: 相遇时slow指针在环内尚未走过完整的一圈。 proof: 若slow指针在环入口处与fast指针相遇，则此时slow指针尚未走过完整的一圈。若slow指针在环入口处尚未与fast指针相遇，则此时slow指针与fast指针的相对距离小于一圈，又因为fast指针追击slow指针的相对速度为1，则在slow指针尚未走过一圈的时间内，fast指针就将追击slow指针。故相遇时slow指针在环内尚未走过完整的一圈。 相遇时slow指针走过的距离可表示为x+y，fast指针走过的距离可表示为x+n(y+z)+y 有等式2(x+y) = x+y+n(y+z)，化简有x=(n-1)(y+z) + z 新建指针ptr指向head。令fast指针与ptr指针同时以速度1向前移动，则fast指针与ptr指针将在环入口处相遇。 代码 # class ListNode { int val; ListNode next; ListNode (int x) { val = x; next = null; } } public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null &amp;amp;&amp;amp; fast.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0143.-Reorder-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0143.-Reorder-List/</guid>
      <description>143. Reorder List # 题目 # 给定一个单链表 L 的头节点 head ，单链表 L 表示为：
L0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为：
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
思路 # 寻找链表中心结点 + 翻转链表 + 合并链表
代码 # 暴力解 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0144.-Binary-Tree-Preorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0144.-Binary-Tree-Preorder-Traversal/</guid>
      <description>144. Binary Tree Preorder Traversal # 题目 # 给定二叉树的根节点 root，返回它节点值的 前序 遍历。
思路 # 代码 # 暴力解 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public void traversal(TreeNode root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0145.-Binary-Tree-Postorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0145.-Binary-Tree-Postorder-Traversal/</guid>
      <description>145. Binary Tree Postorder Traversal # 题目 # 给定二叉树的根节点 root，返回它节点值的 后序 遍历。
思路 # 代码 # 暴力解 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public void traversal(TreeNode root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; traverse(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0146.-LRU-Cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0146.-LRU-Cache/</guid>
      <description>146. LRU Cache # 题目 # 设计并实现一个满足 LRU（最近最少使用）缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value；如果不存在，则向缓存中插入该组 key-value，如果插入操作导致关键字数量超过 capacity，则应该逐出最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 思路 # 使用 双向链表 结合 哈希表 实现 LRU Cache 数据结构。
代码 # class LRUCache { private class ListNode { int key; int val; public ListNode prev; public ListNode next; ListNode (int key, int val, ListNode prev, ListNode next) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0147.-Insertion-Sort-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0147.-Insertion-Sort-List/</guid>
      <description>147. Insertion Sort List # 题目 # 给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。
插入排序 算法的步骤:
插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 思路 # 代码 # class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode insertSortList(ListNode head) { ListNode sentinel = new ListNode(-1, head); /** 设置 preserve 指向已排序链表的尾结点，每次新处理的结点为 preserve.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0148.-Sort-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0148.-Sort-List/</guid>
      <description>148. Sort List # 题目 # 给定链表头结点 head，将其按 升序 排列并返回 排序后的链表
思路 # 分治，归并排序：寻找链表中心结点，分别对链表前半段和后半段排序，合并排序后的前半段链表和后半段链表 代码 # public class ListNode int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode mergeTwoLists(ListNode headA, ListNode headB) { if (headA == null) return headB; if (headB == null) return headA; ListNode sentinel = new ListNode(-1, null); ListNode ptr = sentinel; while (headA !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0150.-Evaluate-Reverse-Polish-Notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0150.-Evaluate-Reverse-Polish-Notation/</guid>
      <description>150. Evaluate Reverse Polish Notation # 题目 # 给定字符串数组 tokens，表示一个根据 逆波兰表示法 表示的算术表达式。
返回表达式的值。
注意：
有效的算符为 &#39;+&#39;、&#39;-&#39;、&#39;*&#39; 和 &#39;/&#39; 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 思路 # 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 代码 # class Solution { public int evalRPN(String[] tokens) { Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for(String token: tokens) { switch (token) { case &amp;#34;+&amp;#34; : stack.push(stack.pop() + stack.pop()); break; case &amp;#34;-&amp;#34; : int operand_2 = stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0160.-Intersection-of-Two-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0160.-Intersection-of-Two-Linked-List/</guid>
      <description>160. Intersection of Two Linked Lists # 题目 # 给定两个单链表的头节点headA和headB，找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode ptrA = headA, ptrB = headB; while (ptrA != ptrB) { ptrA = ptrA.next; ptrB = ptrB.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0191.-Number-of-1-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0191.-Number-of-1-Bits/</guid>
      <description> 191. Number of 1 Bits # 题目 # 编写一个函数，输入是一个无符号整数 (以二进制串的形式)，返回其二进制表达式中数字位数位 &#39;1&#39; 的个数，也称为 汉明重量。
在 Java 中，整数的表示有以下两个特点：
没有无符号整数类型，输入和输出都将被指定为有符号整数类型。 编译器使用 二进制补码 表示有符号整数。 思路 # 代码 # public class Solution { public int hamingWeight(int n) { int numOnes = 0; for (int i = 31; i &amp;gt;= 0; i--) { if ( ((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 1 ) numOnes += 1; } return numOnes;s } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0199.-Binary-Tree-Right-Side-View/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0100-to-0199/0199.-Binary-Tree-Right-Side-View/</guid>
      <description>199. Binary Tree Right Side View # 题目 # 给定一个二叉树的 根节点 root，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;Integer&amp;gt; rightSideView(TreeNode root) { List&amp;lt;Integer&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
  </channel>
</rss>
