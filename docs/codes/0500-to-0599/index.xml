<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/</link>
    <description>Recent content on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/docs/codes/0500-to-0599/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0500.-Keyboard-Row/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0500.-Keyboard-Row/</guid>
      <description>0500. Keyboard Row # 题目 # 给定字符串数组 words ，返回可以使用在 美式键盘 同一行的字母打印出来的单词。 美式键盘 中： 第一行由字符 &amp;quot;qwertyuiop&amp;quot; 组成。 第二行由字符 &amp;quot;asdfghjkl&amp;quot; 组成。 第三行由字符 &amp;quot;zxcvbnm&amp;quot; 组成。 思路 # 模拟+打表 # 代码 # 模拟+打表 # class Solution { public void mapping (int[] qwerty) { qwerty[&amp;#39;q&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;w&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;e&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;r&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;t&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;y&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;u&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;i&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;o&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;p&amp;#39;-&amp;#39;a&amp;#39;] = 0; qwerty[&amp;#39;a&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;s&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;d&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;f&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;g&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;h&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;j&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;k&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;l&amp;#39;-&amp;#39;a&amp;#39;] = 1; qwerty[&amp;#39;z&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;x&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;c&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;v&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;b&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;n&amp;#39;-&amp;#39;a&amp;#39;] = 2; qwerty[&amp;#39;m&amp;#39;-&amp;#39;a&amp;#39;] = 2; } public String[] findWords(String[] words) { int[] qwerty = new int[26]; mapping(qwerty); List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for (String word: words) { boolean ok = true; for (int i = 0; i &amp;lt; word.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0513.-Find-Bottom-Left-Tree-Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0513.-Find-Bottom-Left-Tree-Value/</guid>
      <description>513. Find Bottom Left Tree Value # 题目 # 给定一棵二叉树的 根节点 root，找出该二叉树的 最底层 最左边 节点的值。
假定二叉树至少有一个节点。
思路 # 层数遍历 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int findBottomLeftValue(TreeNode root) { int ans = root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0515.-Find-Largest-Value-in-Each-Tree-Row/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0515.-Find-Largest-Value-in-Each-Tree-Row/</guid>
      <description>515. Find Largest Value in Each Tree Row # 题目 # 给定一棵二叉树的根节点 root，找出该二叉树中每一层的最大值。
思路 # 代码 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public List&amp;lt;Integer&amp;gt; largestValues(TreeNode root) { List&amp;lt;Integer&amp;gt; ans = new LinkedList&amp;lt;&amp;gt;(); if (root == null) return ans; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0520.-Detect-Capital/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0520.-Detect-Capital/</guid>
      <description>0520. Detect Capital # 题目 # 定义单词的大写用法的正确使用情景为：
全部字母都是大写，比如 &amp;quot;USA&amp;quot; 。 单词中所有字母都不是大写，比如 &amp;quot;leetcode&amp;quot; 。 如果单词不只含有一个字母，只有首字母大写， 比如 &amp;quot;Google&amp;quot; 。 给定字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。
思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean detectCapitalUse(String word) { int cnt = 0; for (int i = 0; i &amp;lt; word.length(); i++) { if (Character.isUpperCase(word.charAt(i))) cnt++; } return cnt == word.length() || cnt == 0 || (cnt == 1 &amp;amp;&amp;amp; Character.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0541.-Reverse-String-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0541.-Reverse-String-ii/</guid>
      <description>541. Reverse String II # 题目 # 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 思路 # 代码 # class Solution { public void reversePart(char[] charArray, int left, int right) { while (left &amp;lt; right) { char temp = charArray[left]; charArray[left] = charArray[right]; charArray[right] = temp; left += 1; right -= 1; } } public String reverseStr(String s, int k) { char[] charArray = s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0551.-Student-Attendance-Record-i/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0551.-Student-Attendance-Record-i/</guid>
      <description>0551. Student Attendance Record I # 题目 # 给定表示学生出勤记录的字符串 s ，每个字符用于标记当天的出勤情况。
记录中只含下面三种字符：
&#39;A&#39;：Absent，缺勤 &#39;L&#39;：Late，迟到 &#39;P&#39;：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
按 总出勤 计，学生缺勤（&#39;A&#39;）严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&#39;L&#39;）记录。 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean checkRecord(String s) { int numAbsent = 0, numLate = 0; for (int i = 0; i &amp;lt; s.length(); i++) { if (s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0557.-Reverse-Words-in-a-String-iii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0557.-Reverse-Words-in-a-String-iii/</guid>
      <description>0557. Reverse Words in a String iii # 题目 # 给定字符串 s，反转字符串中每个单词的字符顺序，同时保留空格和单词的初始顺序。 思路 # 双指针 # 代码 # 双指针 # class Solution { public String reverseWords(String s) { String[] words = s.split(&amp;#34; &amp;#34;); for (int i = 0; i &amp;lt; words.length; i++) { char[] charArray = words[i].toCharArray(); int left = 0, right = charArray.length - 1; while (left &amp;lt; right) { char temp = charArray[left]; charArray[left] = charArray[right]; charArray[right] = temp; left++; right--; } words[i] = String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0559.-Maximum-Depth-of-N-ary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0559.-Maximum-Depth-of-N-ary-Tree/</guid>
      <description>0559. Maximum Depth of N-ary Tree # 题目 # 给定一个 n 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
思路 # 层序遍历 代码 # class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } } class Solution { public int maxDepth(Node root) { if (root == null) return 0; int depth = 0; Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0563.-Binary-Tree-Tilt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0563.-Binary-Tree-Tilt/</guid>
      <description>0563. Binary Tree Tilt # 题目 # 给定二叉树根节点 root ，计算并返回 整个树 的坡度 。 一个树的 节点的坡度 定义为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。 整个树 的坡度是其所有节点的坡度之和。 思路 # 递归 # 代码 # 递归 # public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } class Solution { public int sum(TreeNode root, List&amp;lt;Integer&amp;gt; tilt) { if (root == null) return 0; int leftSum = sum(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0566.-Reshape-the-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0566.-Reshape-the-Matrix/</guid>
      <description> 566. Reshape the Matrix # 题目 # 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。
给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。
重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。
如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。
思路 # 代码 # class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int M = mat.length, N = mat[0].length; if (M * N != r * c) return mat; int[][] ans = new int[r][c]; for (int i = 0; i &amp;lt; r; i++) { for (int j = 0; j &amp;lt; c; j++) { int index = i * c + j; int mIndex = index / N, nIndex = index % N; ans[i][j] = mat[mIndex][nIndex]; } } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0589.-N-ary-Tree-Preorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0589.-N-ary-Tree-Preorder-Traversal/</guid>
      <description>589. N-ary Tree Preorder Traversal # 题目 # 给定一个 n 叉树的根节点 root，返回其节点值的 前序遍历。
思路 # 递归 迭代 代码 # 递归 # class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } } class Solution { public void traversal(Node root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0590.-N-ary-Tree-Postorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0500-to-0599/0590.-N-ary-Tree-Postorder-Traversal/</guid>
      <description>590. N-ary Tree Postorder Traversal # 题目 # 给定一个 n 叉树的根节点 root，返回其节点值的 后序遍历。
思路 # 递归 迭代 代码 # 递归 # class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } } class Solution { public void traversal(Node root, List&amp;lt;Integer&amp;gt; ans) { if (root == null) return; for (Node child: root.</description>
    </item>
    
  </channel>
</rss>
