<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Recipe</title>
    <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/</link>
    <description>Recent content on LeetCode Recipe</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://leetcode.akaeecs.com/docs/codes/0800-to-0899/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0817.-Linked-List-Components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0817.-Linked-List-Components/</guid>
      <description>0817. Linked List Components # 题目 # 给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值。同时给定列表 nums，该列表是上述链表中整型值的一个子集。
返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public int numComponents(ListNode head, int[] nums) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for(int x: nums) set.add(x); boolean flag = false; int num = 0; ListNode ptr = head; while (ptr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0821.-Shortest-Distance-to-a-Character/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0821.-Shortest-Distance-to-a-Character/</guid>
      <description>0821. Shortest Distance to a Character # 题目 # 给定字符串 s 和一个字符 c，且 c 是 s 中出现过的字符。 返回整数数组 answer，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离他 最近 的字符 c 的距离。 两个下标 i 和 j 之间的 距离 为 abs(i - j)，其中 abs 是绝对值函数。 思路 # 双向遍历 # BFS # 代码 # 双向遍历 # class Solution { public int[] shortestToChar(String s, char c) { /** 双向扫描数组 */ int[] ans = new int[s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0832.-Flipping-an-Image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0832.-Flipping-an-Image/</guid>
      <description>0832. Flipping an Image # 题目 # 给定一个 n x n 的二进制矩阵 image ，先 水平 翻转图像，然后 反转 图像并返回 结果 。
水平翻转图片就是将图片的每一行都进行翻转，即逆序。
例如，水平翻转 [1,1,0] 的结果是 [0,1,1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。
例如，反转 [0,1,1] 的结果是 [1,0,0]。
思路 # 代码 # class Solution { public void swap(int[][] image, int r1, int c1, int r2, int c2) { /** 对于数组元素来讲，这里的最终结果都是0*/ image[r1][c1] ^= image[r2][c2]; image[r2][c2] ^= image[r1][c1]; image[r1][c1] ^= image[r2][c2]; } public int[][] flipAndInvertImage(int[][] image) { int M = image.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0844.-Backspace-String-Compare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0844.-Backspace-String-Compare/</guid>
      <description>0844. Backspace String Compare # 题目 # 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true。# 代表退格字符。 对空文本输入退格字符，文本继续为空。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean backspaceCompare(String s, String t) { int ptrS = s.length() - 1, ptrT = t.length() - 1; int cntS = 0, cntT = 0; while (ptrS &amp;gt;= 0 &amp;amp;&amp;amp; ptrT &amp;gt;= 0) { while (ptrS &amp;gt;= 0) { if (s.charAt(ptrS) == &amp;#39;#&amp;#39;) { cntS++; ptrS--; } else if (cntS &amp;gt; 0) { cntS--; ptrS--; } else break; } while (ptrT &amp;gt;= 0) { if (t.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0859.-Buddy-Strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0859.-Buddy-Strings/</guid>
      <description>0859. Buddy Strings # 题目 # 给定两个字符串 s 和 goal，若可以通过交换 s 中的两个字母后得到与 goal 相同的结果，则认为 s 与 goal 是亲密字符串。 判断给定的两个字符串是否是亲密字符串。 思路 # 模拟 # 代码 # 模拟 # class Solution { public boolean buddyStrings(String s, String goal) { if (s.length() != goal.length()) return false; Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; s.length; i++) { if (s.charAt(i) != goal.charAt(i)) stack.push(i); } if (stack.size() == 0) { int[] count = new int[26]; for (int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0860.-Lemonade-Change/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0860.-Lemonade-Change/</guid>
      <description> 0860. Lemonade Change # 题目 # 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，一次购买一杯。 每位顾客支付 5 美元、10美元或20美元。必须为每名顾客正确找零，即净交易额为每名顾客支付5美元。 一开始手头没有任何零钱。 给定整数数组bills，其中bills[i]是第i位顾客付的账。 如果能给每位顾客正确找零，返回true，否则返回false。 思路 # 贪心 # 代码 # 贪心 # class Solution { public boolean lemonadeChange(int[] bills) { int five = 0, ten = 0; for (int bill: bills) { if (bill == 5) five++; else if (bill == 10) { if (--five &amp;lt; 0) return false; ten++; } else { if (ten &amp;gt; 0) { ten--; if (--five &amp;lt; 0) return false; } else { five -= 3; if (five &amp;lt; 0) return false; } } } return true; } } 致谢 # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0867.-Transpose-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0867.-Transpose-Matrix/</guid>
      <description> 0867. Transpose Matrix # 题目 # 给定一个二维整数数组 matrix，返回 matrix 的 转置矩阵。
矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。
思路 # 代码 # class Solution { public int[][] transpose(int[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] ans = new int[n][m]; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { ans[i][j] = matrix[j][i]; } } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0868.-Binary-Gap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0868.-Binary-Gap/</guid>
      <description> 0868. Binay Gap # 题目 # 给定正整数 n，找到并返回 n 的二进制表示中两个相邻 1 之间的最长距离。若不存在两个相邻的 1，返回 0。
若只有 0 将两个 1 分隔开，则认为这两个 1 彼此相邻。两个 1 之间的距离是它们的二进制表示中位置的绝对差。
思路 # 代码 # class Solution { public int binaryGap(int n) { int gap = 0, flag = -1; for (int i = 31; i &amp;gt;= 0; i--) { if (((n &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) { if (flag &amp;gt; 0) gap = Math.max(gap, flag - i); flag = i; } } return gap; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0876.-Middle-of-the-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://leetcode.akaeecs.com/docs/codes/0800-to-0899/0876.-Middle-of-the-Linked-List/</guid>
      <description>876. Middle of the Linked List # 题目 # 给定一个头结点为head的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
思路 # 代码 # public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode middleNode(ListNode head) { ListNode sentinel = new ListNode(-1, head); ListNode middle = sentinel, fast = sentinel; while (fast != null &amp;amp;&amp;amp; fast.</description>
    </item>
    
  </channel>
</rss>
